; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

include listing.inc

INCLUDELIB OLDNAMES

EXTRN	__report_rangecheckfailure:PROC
EXTRN	__security_check_cookie:PROC
PUBLIC	?median_filter_C@@YAXHHHHPEAD0@Z		; median_filter_C
PUBLIC	?sort_and_merge@@YAXPEAD00PEAC11@Z		; sort_and_merge
PUBLIC	?quicksort@@YAXPEADPEACHH@Z			; quicksort
PUBLIC	?partition@@YACPEADPEACHH@Z			; partition
PUBLIC	__real@40c3880000000000
PUBLIC	__real@412e848000000000
PUBLIC	__xmm@0417120d080316110c070215100b0601
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$?median_filter_C@@YAXHHHHPEAD0@Z DD imagerel $LN1395
	DD	imagerel $LN1395+1627
	DD	imagerel $unwind$?median_filter_C@@YAXHHHHPEAD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?median_filter_C@@YAXHHHHPEAD0@Z DD imagerel $LN1395+1627
	DD	imagerel $LN1395+7136
	DD	imagerel $chain$2$?median_filter_C@@YAXHHHHPEAD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?median_filter_C@@YAXHHHHPEAD0@Z DD imagerel $LN1395+7136
	DD	imagerel $LN1395+7158
	DD	imagerel $chain$3$?median_filter_C@@YAXHHHHPEAD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?median_filter_C@@YAXHHHHPEAD0@Z DD imagerel $LN1395+7158
	DD	imagerel $LN1395+7194
	DD	imagerel $chain$4$?median_filter_C@@YAXHHHHPEAD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?sort_and_merge@@YAXPEAD00PEAC11@Z DD imagerel $LN50
	DD	imagerel $LN50+258
	DD	imagerel $unwind$?sort_and_merge@@YAXPEAD00PEAC11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?quicksort@@YAXPEADPEACHH@Z DD imagerel $LN22
	DD	imagerel $LN22+104
	DD	imagerel $unwind$?quicksort@@YAXPEADPEACHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?partition@@YACPEADPEACHH@Z DD imagerel $LN12
	DD	imagerel $LN12+143
	DD	imagerel $unwind$?partition@@YACPEADPEACHH@Z
;	COMDAT __xmm@0417120d080316110c070215100b0601
CONST	SEGMENT
__xmm@0417120d080316110c070215100b0601 DB 01H, 06H, 0bH, 010H, 015H, 02H, 07H
	DB	0cH, 011H, 016H, 03H, 08H, 0dH, 012H, 017H, 04H
CONST	ENDS
;	COMDAT __real@412e848000000000
CONST	SEGMENT
__real@412e848000000000 DQ 0412e848000000000r	; 1e+006
CONST	ENDS
;	COMDAT __real@40c3880000000000
CONST	SEGMENT
__real@40c3880000000000 DQ 040c3880000000000r	; 10000
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?partition@@YACPEADPEACHH@Z DD 060f01H
	DD	03740fH
	DD	02640aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?quicksort@@YAXPEADPEACHH@Z DD 081901H
	DD	096419H
	DD	085419H
	DD	063419H
	DD	070153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?sort_and_merge@@YAXPEAD00PEAC11@Z DD 0a1a01H
	DD	09e41aH
	DD	08741aH
	DD	07641aH
	DD	06341aH
	DD	0f016321aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?median_filter_C@@YAXHHHHPEAD0@Z DD 060021H
	DD	049f400H
	DD	048d400H
	DD	046c400H
	DD	imagerel $LN1395
	DD	imagerel $LN1395+1627
	DD	imagerel $unwind$?median_filter_C@@YAXHHHHPEAD0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?median_filter_C@@YAXHHHHPEAD0@Z DD 021H
	DD	imagerel $LN1395
	DD	imagerel $LN1395+1627
	DD	imagerel $unwind$?median_filter_C@@YAXHHHHPEAD0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?median_filter_C@@YAXHHHHPEAD0@Z DD 061d21H
	DD	049f41dH
	DD	048d410H
	DD	046c408H
	DD	imagerel $LN1395
	DD	imagerel $LN1395+1627
	DD	imagerel $unwind$?median_filter_C@@YAXHHHHPEAD0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?median_filter_C@@YAXHHHHPEAD0@Z DD 072719H
	DD	0400116H
	DD	07005e007H
	DD	030036004H
	DD	05002H
	DD	imagerel __GSHandlerCheck
	DD	01f8H
xdata	ENDS
; Function compile flags: /Ogtpy
; File c:\data\heterogen\c_optimalizalatlan\_src\hazi.cpp
;	COMDAT ?partition@@YACPEADPEACHH@Z
_TEXT	SEGMENT
nums$ = 8
pos$dead$ = 16
left$ = 24
right$ = 32
?partition@@YACPEADPEACHH@Z PROC			; partition, COMDAT

; 7    : signed char partition(char* nums, signed char* pos, int left, int right){

$LN12:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	movsxd	rbx, r9d

; 8    : 	char tmp, tmp_pos;
; 9    : 	char pivot = nums[right], i, x;
; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	movsx	eax, r8b
	mov	r11, rcx
	movzx	edi, BYTE PTR [rbx+rcx]
	movzx	r10d, r8b
	cmp	eax, ebx
	jge	SHORT $LN2@partition
	npad	11
$LL4@partition:

; 14   : 		if (nums[x] <= pivot){

	movsx	rdx, r8b
	movzx	r9d, BYTE PTR [rdx+r11]
	cmp	r9b, dil
	jg	SHORT $LN3@partition

; 15   : 			SWAP(i, x);

	movsx	rax, r10b
	movzx	ecx, BYTE PTR [rax+r11]
	mov	BYTE PTR [rax+r11], r9b
	movzx	eax, r10b

; 16   : 			i++;

	lea	r10d, DWORD PTR [r8+1]
	movzx	r8d, al
	mov	BYTE PTR [rdx+r11], cl
$LN3@partition:

; 8    : 	char tmp, tmp_pos;
; 9    : 	char pivot = nums[right], i, x;
; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	inc	r8b
	movsx	eax, r8b
	cmp	eax, ebx
	jl	SHORT $LL4@partition
$LN2@partition:

; 17   : 		}
; 18   : 	}
; 19   : 	SWAP(i, right);

	movzx	eax, BYTE PTR [rbx+r11]

; 20   : 	return i;
; 21   : }

	mov	rsi, QWORD PTR [rsp+16]
	mov	rdi, QWORD PTR [rsp+24]
	movsx	rcx, r10b
	movzx	edx, BYTE PTR [rcx+r11]
	mov	BYTE PTR [rcx+r11], al
	movzx	eax, bl
	mov	BYTE PTR [rbx+r11], dl
	mov	rbx, QWORD PTR [rsp+8]
	ret	0
?partition@@YACPEADPEACHH@Z ENDP			; partition
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\data\heterogen\c_optimalizalatlan\_src\hazi.cpp
;	COMDAT ?quicksort@@YAXPEADPEACHH@Z
_TEXT	SEGMENT
nums$ = 48
pos$ = 56
left$ = 64
right$ = 72
?quicksort@@YAXPEADPEACHH@Z PROC			; quicksort, COMDAT

; 24   : void quicksort(char *nums, signed char* pos, int left, int right){

$LN22:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	mov	QWORD PTR [rsp+16], rdx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	esi, r9d
	mov	ebx, r8d
	mov	rbp, rcx
$LL17@quicksort:

; 29   : 		p = partition(nums, pos, left, right);

	mov	r9d, esi
	mov	r8d, ebx
	mov	rcx, rbp
	call	?partition@@YACPEADPEACHH@Z		; partition

; 30   : 		quicksort(nums, pos, left, p - 1);

	movsx	edi, al
	lea	r9d, DWORD PTR [rdi-1]

; 25   : 	//char new_p[5] = {21, 22, 23, 24, 25};
; 26   : 	signed char p;	//p is position of pivot in the partitioned array
; 27   : 	
; 28   : 	if (left < right){

	cmp	ebx, r9d
	jge	SHORT $LN7@quicksort
	mov	rdx, QWORD PTR pos$[rsp]
	mov	r8d, ebx
	mov	rcx, rbp
	call	?quicksort@@YAXPEADPEACHH@Z		; quicksort
$LN7@quicksort:

; 31   : 		quicksort(nums, pos, p + 1, right);

	lea	ebx, DWORD PTR [rdi+1]

; 25   : 	//char new_p[5] = {21, 22, 23, 24, 25};
; 26   : 	signed char p;	//p is position of pivot in the partitioned array
; 27   : 	
; 28   : 	if (left < right){

	cmp	ebx, esi
	jl	SHORT $LL17@quicksort

; 32   : 	}
; 33   : 	return;
; 34   : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?quicksort@@YAXPEADPEACHH@Z ENDP			; quicksort
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\data\heterogen\c_optimalizalatlan\_src\hazi.cpp
;	COMDAT ?sort_and_merge@@YAXPEAD00PEAC11@Z
_TEXT	SEGMENT
a$ = 48
b$ = 56
c$ = 64
a_pos$ = 72
b_pos$ = 80
c_pos$ = 88
?sort_and_merge@@YAXPEAD00PEAC11@Z PROC			; sort_and_merge, COMDAT

; 58   : void sort_and_merge(char* a, char* b, char* c, signed char* a_pos, signed char* b_pos, signed char* c_pos){

$LN50:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	mov	QWORD PTR [rsp+32], r14
	push	r15
	sub	rsp, 32					; 00000020H
	mov	rsi, rdx

; 9    : 	char pivot = nums[right], i, x;

	movzx	edx, BYTE PTR [r8+4]

; 58   : void sort_and_merge(char* a, char* b, char* c, signed char* a_pos, signed char* b_pos, signed char* c_pos){

	mov	rdi, r8

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	xor	r8b, r8b

; 58   : void sort_and_merge(char* a, char* b, char* c, signed char* a_pos, signed char* b_pos, signed char* c_pos){

	mov	rbx, r9
	mov	r15, rcx

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	xor	r9b, r9b
$LL16@sort_and_m:

; 14   : 		if (nums[x] <= pivot){

	movsx	r10, r8b
	movzx	r11d, BYTE PTR [r10+rdi]
	cmp	r11b, dl
	jg	SHORT $LN15@sort_and_m

; 15   : 			SWAP(i, x);

	movsx	rax, r9b
	movzx	ecx, BYTE PTR [rax+rdi]
	mov	BYTE PTR [rax+rdi], r11b
	movzx	eax, r9b

; 16   : 			i++;

	lea	r9d, DWORD PTR [r8+1]
	movzx	r8d, al
	mov	BYTE PTR [r10+rdi], cl
$LN15@sort_and_m:

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	inc	r8b
	cmp	r8b, 4
	jl	SHORT $LL16@sort_and_m
	mov	r14, QWORD PTR c_pos$[rsp]

; 17   : 		}
; 18   : 	}
; 19   : 	SWAP(i, right);

	movsx	rax, r9b
	xor	r8d, r8d
	movzx	edx, BYTE PTR [rax+rdi]
	lea	rcx, QWORD PTR [rax+rdi]
	movzx	eax, BYTE PTR [rdi+4]
	mov	BYTE PTR [rcx], al
	mov	BYTE PTR [rdi+4], dl
	mov	r9d, 3
	mov	rdx, r14
	mov	rcx, rdi
	call	?quicksort@@YAXPEADPEACHH@Z		; quicksort

; 59   : 	int i, j, k;
; 60   : 	quicksort(c, c_pos, 0, FILTER_W-1);
; 61   : 	for(i = 0,j = 0, k = 0; i < FILTER_W * FILTER_H; i++){

	mov	r8, QWORD PTR b_pos$[rsp]
	mov	r9, rbx
	sub	r15, rbx
	sub	rsi, rbx
	neg	r9
	sub	r8, rbx
	sub	r14, rdi
	npad	7
$LL7@sort_and_m:

; 62   : 		while(a_pos[i] < 1) k++;

	movzx	eax, BYTE PTR [rbx]
	cmp	al, 1
	jl	SHORT $LL4@sort_and_m

; 63   : 		if(a[i+k] <= c[j]) {

	movzx	ecx, BYTE PTR [r15+rbx]
	movzx	edx, BYTE PTR [rdi]
	cmp	cl, dl
	jg	SHORT $LN2@sort_and_m

; 64   : 			b[i] = a[i+k];

	mov	BYTE PTR [rsi+rbx], cl

; 65   : 			b_pos[i] = a_pos[i+k];
; 66   : 		}
; 67   : 		else {

	jmp	SHORT $LN48@sort_and_m
$LN2@sort_and_m:

; 68   : 			b[i] = c[j];
; 69   : 			b_pos[i] = c_pos[j];

	movzx	eax, BYTE PTR [r14+rdi]

; 70   : 			j++;

	inc	rdi
	mov	BYTE PTR [rsi+rbx], dl
$LN48@sort_and_m:

; 59   : 	int i, j, k;
; 60   : 	quicksort(c, c_pos, 0, FILTER_W-1);
; 61   : 	for(i = 0,j = 0, k = 0; i < FILTER_W * FILTER_H; i++){

	mov	BYTE PTR [r8+rbx], al
	inc	rbx
	lea	rax, QWORD PTR [r9+rbx]
	cmp	rax, 25
	jl	SHORT $LL7@sort_and_m

; 71   : 		}
; 72   : 	}
; 73   : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	mov	r14, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r15
	ret	0
	npad	1
$LL4@sort_and_m:

; 62   : 		while(a_pos[i] < 1) k++;

	jmp	SHORT $LL4@sort_and_m
?sort_and_merge@@YAXPEAD00PEAC11@Z ENDP			; sort_and_merge
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\data\heterogen\c_optimalizalatlan\_src\hazi.cpp
;	COMDAT ?median_filter_C@@YAXHHHHPEAD0@Z
_TEXT	SEGMENT
Y$1$ = 32
imgWidth$GSCopy$1$ = 36
imgDst$GSCopy$1$ = 40
imgWidthF$1$ = 48
tv12264 = 56
imgHeight$1$ = 64
b_new$ = 68
g_new$ = 76
r_new$ = 84
g_new_p$ = 92
r_new_p$ = 100
b_new_p$ = 108
b_a_p$ = 120
g_a_p$ = 152
r_a_p$ = 184
r_b_p$ = 216
g_b_p$ = 248
b_b_p$ = 280
r_a$ = 312
b_b$ = 344
r_b$ = 376
g_b$ = 408
g_a$ = 440
b_a$ = 472
__$ArrayPad$ = 504
imgHeight$ = 560
imgWidth$ = 568
imgWidthF$ = 576
imgFOffsetW$dead$ = 584
imgSrc$ = 592
imgDst$ = 600
?median_filter_C@@YAXHHHHPEAD0@Z PROC			; median_filter_C, COMDAT

; 192  : void median_filter_C(int imgHeight, int imgWidth, int imgWidthF, int imgFOffsetW, char* imgSrc, char* imgDst){

$LN1395:
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r14
	lea	rbp, QWORD PTR [rsp-256]
	sub	rsp, 512				; 00000200H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	rsi, QWORD PTR imgSrc$[rbp-256]
	mov	rax, QWORD PTR imgDst$[rbp-256]

; 193  : 
; 194  : 	int X, Y = 0;

	xor	ebx, ebx
	vxorps	xmm0, xmm0, xmm0
	movsxd	rdi, r8d
	mov	DWORD PTR imgWidthF$1$[rsp], r8d
	mov	DWORD PTR imgWidth$GSCopy$1$[rsp], edx
	vmovdqu	XMMWORD PTR r_a$[rbp-256], xmm0
	vmovdqu	XMMWORD PTR r_b$[rbp-256], xmm0
	vmovdqu	XMMWORD PTR g_a$[rbp-256], xmm0
	shl	rdi, 2
	mov	r14d, ecx
	mov	DWORD PTR imgHeight$1$[rsp], ecx
	vmovdqu	XMMWORD PTR g_b$[rbp-256], xmm0
	vmovdqu	XMMWORD PTR b_a$[rbp-256], xmm0
	vmovdqu	XMMWORD PTR b_b$[rbp-256], xmm0
	mov	QWORD PTR imgDst$GSCopy$1$[rsp], rax
	mov	DWORD PTR Y$1$[rsp], ebx

; 195  : 	int i, j;
; 196  : 	
; 197  : 	//Tables for filter windows
; 198  : 	char r_a[FILTER_H * FILTER_W] = {0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0};

	mov	QWORD PTR r_a$[rbp-240], rbx
	vmovdqu	xmm0, XMMWORD PTR __xmm@0417120d080316110c070215100b0601
	mov	BYTE PTR r_a$[rbp-232], bl

; 199  : 	char r_b[FILTER_H * FILTER_W] = {0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0};

	mov	QWORD PTR r_b$[rbp-240], rbx
	mov	BYTE PTR r_b$[rbp-232], bl
	vmovdqu	XMMWORD PTR r_a_p$[rbp-256], xmm0
	vmovdqu	XMMWORD PTR r_b_p$[rbp-256], xmm0
	vmovdqu	XMMWORD PTR g_a_p$[rbp-256], xmm0

; 200  : 	char g_a[FILTER_H * FILTER_W] = {0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0};

	mov	QWORD PTR g_a$[rbp-240], rbx
	mov	BYTE PTR g_a$[rbp-232], bl

; 201  : 	char g_b[FILTER_H * FILTER_W] = {0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0};

	mov	QWORD PTR g_b$[rbp-240], rbx
	vmovdqu	XMMWORD PTR g_b_p$[rbp-256], xmm0
	vmovdqu	XMMWORD PTR b_a_p$[rsp], xmm0
	vmovdqu	XMMWORD PTR b_b_p$[rbp-256], xmm0
	mov	BYTE PTR g_b$[rbp-232], bl

; 202  : 	char b_a[FILTER_H * FILTER_W] = {0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0};

	mov	QWORD PTR b_a$[rbp-240], rbx
	mov	BYTE PTR b_a$[rbp-232], bl

; 203  : 	char b_b[FILTER_H * FILTER_W] = {0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0};

	mov	QWORD PTR b_b$[rbp-240], rbx
	mov	BYTE PTR b_b$[rbp-232], bl

; 204  : 	signed char r_a_p[FILTER_H * FILTER_W] = {1,6,11,16,21, 2,7,12,17,22, 3,8,13,18,23, 4,9,14,19,24, 5,10,15,20,25};

	mov	DWORD PTR r_a_p$[rbp-240], 403901961	; 18130e09H
	mov	DWORD PTR r_a_p$[rbp-236], 336529925	; 140f0a05H
	mov	BYTE PTR r_a_p$[rbp-232], 25

; 205  : 	signed char r_b_p[FILTER_H * FILTER_W] = {1,6,11,16,21, 2,7,12,17,22, 3,8,13,18,23, 4,9,14,19,24, 5,10,15,20,25};

	mov	DWORD PTR r_b_p$[rbp-240], 403901961	; 18130e09H
	mov	DWORD PTR r_b_p$[rbp-236], 336529925	; 140f0a05H
	mov	BYTE PTR r_b_p$[rbp-232], 25

; 206  : 	signed char g_a_p[FILTER_H * FILTER_W] = {1,6,11,16,21, 2,7,12,17,22, 3,8,13,18,23, 4,9,14,19,24, 5,10,15,20,25};

	mov	DWORD PTR g_a_p$[rbp-240], 403901961	; 18130e09H
	mov	DWORD PTR g_a_p$[rbp-236], 336529925	; 140f0a05H
	mov	BYTE PTR g_a_p$[rbp-232], 25

; 207  : 	signed char g_b_p[FILTER_H * FILTER_W] = {1,6,11,16,21, 2,7,12,17,22, 3,8,13,18,23, 4,9,14,19,24, 5,10,15,20,25};

	mov	DWORD PTR g_b_p$[rbp-240], 403901961	; 18130e09H
	mov	DWORD PTR g_b_p$[rbp-236], 336529925	; 140f0a05H
	mov	BYTE PTR g_b_p$[rbp-232], 25

; 208  : 	signed char b_a_p[FILTER_H * FILTER_W] = {1,6,11,16,21, 2,7,12,17,22, 3,8,13,18,23, 4,9,14,19,24, 5,10,15,20,25};

	mov	DWORD PTR b_a_p$[rbp-240], 403901961	; 18130e09H
	mov	DWORD PTR b_a_p$[rbp-236], 336529925	; 140f0a05H
	mov	BYTE PTR b_a_p$[rbp-232], 25

; 209  : 	signed char b_b_p[FILTER_H * FILTER_W] = {1,6,11,16,21, 2,7,12,17,22, 3,8,13,18,23, 4,9,14,19,24, 5,10,15,20,25};

	mov	DWORD PTR b_b_p$[rbp-240], 403901961	; 18130e09H
	mov	DWORD PTR b_b_p$[rbp-236], 336529925	; 140f0a05H
	mov	BYTE PTR b_b_p$[rbp-232], 25

; 210  : 	char r_new[FILTER_H];
; 211  : 	char g_new[FILTER_H];
; 212  : 	char b_new[FILTER_H];
; 213  : 	signed char r_new_p[FILTER_H] = {5,5,5,5,5};

	mov	DWORD PTR r_new_p$[rsp], 84215045	; 05050505H
	mov	BYTE PTR r_new_p$[rsp+4], 5

; 214  : 	signed char g_new_p[FILTER_H] = {5,5,5,5,5};

	mov	DWORD PTR g_new_p$[rsp], 84215045	; 05050505H
	mov	BYTE PTR g_new_p$[rsp+4], 5

; 215  : 	signed char b_new_p[FILTER_H] = {5,5,5,5,5};

	mov	DWORD PTR b_new_p$[rsp], 84215045	; 05050505H
	mov	BYTE PTR b_new_p$[rsp+4], 5
	mov	QWORD PTR tv12264[rsp], rdi
	lea	rcx, QWORD PTR [rsi+17]

; 216  : 	int base, base_out;
; 217  : 	
; 218  : 	//[0;-2] pixel
; 219  : 	
; 220  : 	for(i = 0; i < FILTER_W; i++){
; 221  : 		r_new[i] = imgSrc[(i * imgWidthF + imgFOffsetW - 2) * 4];

	mov	edx, ebx
	lea	r8d, QWORD PTR [rbx+5]
	npad	3
$LL77@median_fil:
	movzx	eax, BYTE PTR [rcx-1]
	inc	rdx
	mov	BYTE PTR r_new$[rsp+rdx-1], al

; 222  : 		g_new[i] = imgSrc[(i * imgWidthF + imgFOffsetW - 2) * 4 + 1];

	movzx	eax, BYTE PTR [rcx]
	mov	BYTE PTR g_new$[rsp+rdx-1], al

; 223  : 		b_new[i] = imgSrc[(i * imgWidthF + imgFOffsetW - 2) * 4 + 2];

	movzx	eax, BYTE PTR [rcx+1]
	add	rcx, rdi
	mov	BYTE PTR b_new$[rsp+rdx-1], al
	dec	r8
	jne	SHORT $LL77@median_fil

; 9    : 	char pivot = nums[right], i, x;

	movzx	r11d, BYTE PTR r_new$[rsp+4]

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	xor	dl, dl
	npad	6
$LL98@median_fil:

; 14   : 		if (nums[x] <= pivot){

	lea	r9, QWORD PTR r_new$[rsp]
	movsx	rax, dl
	add	r9, rax
	movzx	r10d, BYTE PTR [r9]
	cmp	r10b, r11b
	jg	SHORT $LN97@median_fil

; 15   : 			SWAP(i, x);

	movsx	rax, r8b
	movzx	ecx, BYTE PTR r_new$[rsp+rax]
	mov	BYTE PTR r_new$[rsp+rax], r10b
	movzx	eax, r8b

; 16   : 			i++;

	lea	r8d, DWORD PTR [rdx+1]
	movzx	edx, al
	mov	BYTE PTR [r9], cl
$LN97@median_fil:

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	inc	dl
	cmp	dl, 4
	jl	SHORT $LL98@median_fil

; 17   : 		}
; 18   : 	}
; 19   : 	SWAP(i, right);

	movsx	rax, r8b
	lea	rcx, QWORD PTR r_new$[rsp]
	mov	r9d, 3
	add	rcx, rax
	movzx	eax, BYTE PTR r_new$[rsp+4]
	xor	r8d, r8d
	movzx	edx, BYTE PTR [rcx]
	mov	BYTE PTR [rcx], al
	lea	rcx, QWORD PTR r_new$[rsp]
	mov	BYTE PTR r_new$[rsp+4], dl
	lea	rdx, QWORD PTR r_new_p$[rsp]
	call	?quicksort@@YAXPEADPEACHH@Z		; quicksort

; 9    : 	char pivot = nums[right], i, x;

	movzx	r11d, BYTE PTR g_new$[rsp+4]

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	xor	dl, dl
	xor	r8b, r8b
	npad	11
$LL117@median_fil:

; 14   : 		if (nums[x] <= pivot){

	lea	r9, QWORD PTR g_new$[rsp]
	movsx	rax, dl
	add	r9, rax
	movzx	r10d, BYTE PTR [r9]
	cmp	r10b, r11b
	jg	SHORT $LN116@median_fil

; 15   : 			SWAP(i, x);

	movsx	rax, r8b
	movzx	ecx, BYTE PTR g_new$[rsp+rax]
	mov	BYTE PTR g_new$[rsp+rax], r10b
	movzx	eax, r8b

; 16   : 			i++;

	lea	r8d, DWORD PTR [rdx+1]
	movzx	edx, al
	mov	BYTE PTR [r9], cl
$LN116@median_fil:

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	inc	dl
	cmp	dl, 4
	jl	SHORT $LL117@median_fil

; 17   : 		}
; 18   : 	}
; 19   : 	SWAP(i, right);

	movsx	rax, r8b
	lea	rcx, QWORD PTR g_new$[rsp]
	mov	r9d, 3
	add	rcx, rax
	movzx	eax, BYTE PTR g_new$[rsp+4]
	xor	r8d, r8d
	movzx	edx, BYTE PTR [rcx]
	mov	BYTE PTR [rcx], al
	lea	rcx, QWORD PTR g_new$[rsp]
	mov	BYTE PTR g_new$[rsp+4], dl
	lea	rdx, QWORD PTR g_new_p$[rsp]
	call	?quicksort@@YAXPEADPEACHH@Z		; quicksort

; 9    : 	char pivot = nums[right], i, x;

	movzx	r11d, BYTE PTR b_new$[rsp+4]

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	xor	dl, dl
	xor	r8b, r8b
	npad	11
$LL136@median_fil:

; 14   : 		if (nums[x] <= pivot){

	lea	r9, QWORD PTR b_new$[rsp]
	movsx	rax, dl
	add	r9, rax
	movzx	r10d, BYTE PTR [r9]
	cmp	r10b, r11b
	jg	SHORT $LN135@median_fil

; 15   : 			SWAP(i, x);

	movsx	rax, r8b
	movzx	ecx, BYTE PTR b_new$[rsp+rax]
	mov	BYTE PTR b_new$[rsp+rax], r10b
	movzx	eax, r8b

; 16   : 			i++;

	lea	r8d, DWORD PTR [rdx+1]
	movzx	edx, al
	mov	BYTE PTR [r9], cl
$LN135@median_fil:

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	inc	dl
	cmp	dl, 4
	jl	SHORT $LL136@median_fil

; 17   : 		}
; 18   : 	}
; 19   : 	SWAP(i, right);

	movsx	rax, r8b
	lea	rcx, QWORD PTR b_new$[rsp]
	mov	r9d, 3
	add	rcx, rax
	movzx	eax, BYTE PTR b_new$[rsp+4]
	xor	r8d, r8d
	movzx	edx, BYTE PTR [rcx]
	mov	BYTE PTR [rcx], al
	lea	rcx, QWORD PTR b_new$[rsp]
	mov	BYTE PTR b_new$[rsp+4], dl
	lea	rdx, QWORD PTR b_new_p$[rsp]
	call	?quicksort@@YAXPEADPEACHH@Z		; quicksort

; 224  : 	}
; 225  : 	quicksort(r_new, r_new_p, 0, FILTER_W-1);
; 226  : 	quicksort(g_new, g_new_p, 0, FILTER_W-1);
; 227  : 	quicksort(b_new, b_new_p, 0, FILTER_W-1);
; 228  : 
; 229  : 	for(i = (FILTER_H - 1) * FILTER_W, j = 0; j < FILTER_W; j++){
; 230  : 		r_b[i + j]	= r_new[j];
; 231  : 		g_b[i + j]	= g_new[j];
; 232  : 		b_b[i + j]	= b_new[j];

	mov	eax, DWORD PTR b_new$[rsp]
	mov	edx, ebx
	mov	DWORD PTR b_b$[rbp-236], eax
	movzx	eax, BYTE PTR b_new$[rsp+4]
	mov	rcx, rbx
	mov	BYTE PTR b_b$[rbp-232], al
	mov	eax, DWORD PTR g_new$[rsp]
	mov	DWORD PTR g_b$[rbp-236], eax
	movzx	eax, BYTE PTR g_new$[rsp+4]
	mov	BYTE PTR g_b$[rbp-232], al
	mov	eax, DWORD PTR r_new$[rsp]
	mov	DWORD PTR r_b$[rbp-236], eax
	movzx	eax, BYTE PTR r_new$[rsp+4]
	mov	BYTE PTR r_b$[rbp-232], al
	npad	8
$LL74@median_fil:

; 233  : 		r_b_p[i + j] = r_new_p[j];

	movzx	eax, BYTE PTR r_new_p$[rsp+rcx]
	lea	rcx, QWORD PTR [rcx+1]
	mov	BYTE PTR r_b_p$[rbp+rcx-237], al

; 234  : 		g_b_p[i + j] = g_new_p[j];

	movzx	eax, BYTE PTR g_new_p$[rsp+rcx-1]
	mov	BYTE PTR g_b_p$[rbp+rcx-237], al

; 235  : 		b_b_p[i + j] = b_new_p[j];

	movzx	eax, BYTE PTR b_new_p$[rsp+rcx-1]
	mov	BYTE PTR b_b_p$[rbp+rcx-237], al

; 236  : 		r_new_p[j] = j + 1;

	lea	eax, DWORD PTR [rdx+1]
	inc	edx
	mov	BYTE PTR r_new_p$[rsp+rcx-1], al

; 237  : 		g_new_p[j] = j + 1;

	mov	BYTE PTR g_new_p$[rsp+rcx-1], al

; 238  : 		b_new_p[j] = j + 1;

	mov	BYTE PTR b_new_p$[rsp+rcx-1], al
	cmp	edx, 5
	jl	SHORT $LL74@median_fil

; 239  : 	}
; 240  : 	
; 241  : 	//[0;-1] pixel
; 242  : 
; 243  : 	//Updating B positions and getting new positions
; 244  : 	for(i = 0; i < FILTER_H * FILTER_W; i++){

	mov	rax, rbx
	mov	ecx, 25
	npad	3
$LL71@median_fil:

; 245  : 		r_b_p[i] = r_b_p[i] - 5;

	add	BYTE PTR r_b_p$[rbp+rax-256], -5

; 246  : 		g_b_p[i] = g_b_p[i] - 5;

	add	BYTE PTR g_b_p$[rbp+rax-256], -5

; 247  : 		b_b_p[i] = b_b_p[i] - 5;

	add	BYTE PTR b_b_p$[rbp+rax-256], -5
	lea	rax, QWORD PTR [rax+1]
	dec	rcx
	jne	SHORT $LL71@median_fil

; 248  : 	}
; 249  : 	
; 250  : 	//Reading new values from the original image
; 251  : 	for(i = 0; i < FILTER_W; i++){

	lea	rcx, QWORD PTR [rsi+21]

; 252  : 		r_new[i] = imgSrc[(i * imgWidthF + imgFOffsetW - 1) * 4];

	mov	rdx, rbx
	mov	r8d, 5
	npad	11
$LL68@median_fil:
	movzx	eax, BYTE PTR [rcx-1]
	inc	rdx
	mov	BYTE PTR r_new$[rsp+rdx-1], al

; 253  : 		g_new[i] = imgSrc[(i * imgWidthF + imgFOffsetW - 1) * 4 + 1];

	movzx	eax, BYTE PTR [rcx]
	mov	BYTE PTR g_new$[rsp+rdx-1], al

; 254  : 		b_new[i] = imgSrc[(i * imgWidthF + imgFOffsetW - 1) * 4 + 2];

	movzx	eax, BYTE PTR [rcx+1]
	add	rcx, rdi
	mov	BYTE PTR b_new$[rsp+rdx-1], al
	dec	r8
	jne	SHORT $LL68@median_fil

; 9    : 	char pivot = nums[right], i, x;

	movzx	r11d, BYTE PTR r_new$[rsp+4]

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	xor	dl, dl
	npad	6
$LL164@median_fil:

; 14   : 		if (nums[x] <= pivot){

	lea	r9, QWORD PTR r_new$[rsp]
	movsx	rax, dl
	add	r9, rax
	movzx	r10d, BYTE PTR [r9]
	cmp	r10b, r11b
	jg	SHORT $LN163@median_fil

; 15   : 			SWAP(i, x);

	movsx	rax, r8b
	movzx	ecx, BYTE PTR r_new$[rsp+rax]
	mov	BYTE PTR r_new$[rsp+rax], r10b
	movzx	eax, r8b

; 16   : 			i++;

	lea	r8d, DWORD PTR [rdx+1]
	movzx	edx, al
	mov	BYTE PTR [r9], cl
$LN163@median_fil:

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	inc	dl
	cmp	dl, 4
	jl	SHORT $LL164@median_fil

; 17   : 		}
; 18   : 	}
; 19   : 	SWAP(i, right);

	movsx	rax, r8b
	lea	rcx, QWORD PTR r_new$[rsp]
	mov	r9d, 3
	add	rcx, rax
	movzx	eax, BYTE PTR r_new$[rsp+4]
	xor	r8d, r8d
	movzx	edx, BYTE PTR [rcx]
	mov	BYTE PTR [rcx], al
	lea	rcx, QWORD PTR r_new$[rsp]
	mov	BYTE PTR r_new$[rsp+4], dl
	lea	rdx, QWORD PTR r_new_p$[rsp]
	call	?quicksort@@YAXPEADPEACHH@Z		; quicksort

; 20   : 	return i;
; 21   : }
; 22   : 
; 23   : 
; 24   : void quicksort(char *nums, signed char* pos, int left, int right){
; 25   : 	//char new_p[5] = {21, 22, 23, 24, 25};
; 26   : 	signed char p;	//p is position of pivot in the partitioned array
; 27   : 	
; 28   : 	if (left < right){
; 29   : 		p = partition(nums, pos, left, right);
; 30   : 		quicksort(nums, pos, left, p - 1);
; 31   : 		quicksort(nums, pos, p + 1, right);
; 32   : 	}
; 33   : 	return;
; 34   : }
; 35   : /*
; 36   : int quickselect(char *nums, char* pos, int left, int right, int k){
; 37   : 	int p = partition(nums, new_p, left, right);	//p is position of pivot in the partitioned array
; 38   : 	int r;
; 39   : 	
; 40   : 	//k equals pivot got lucky
; 41   : 	if (p == k-1){
; 42   : 		r = nums[p];
; 43   : 	}
; 44   : 	//k less than pivot
; 45   : 	else if (k - 1 < p){
; 46   : 		r = quickselect(nums, new_p, left, p - 1, k);
; 47   : 	}
; 48   : 	//k greater than pivot
; 49   : 	else{
; 50   : 		r = quickselect(nums, new_p, p + 1, right, k);
; 51   : 	}
; 52   : 	pos = new_p;
; 53   : 	return r;
; 54   : }
; 55   : */
; 56   : 
; 57   : 
; 58   : void sort_and_merge(char* a, char* b, char* c, signed char* a_pos, signed char* b_pos, signed char* c_pos){
; 59   : 	int i, j, k;
; 60   : 	quicksort(c, c_pos, 0, FILTER_W-1);
; 61   : 	for(i = 0,j = 0, k = 0; i < FILTER_W * FILTER_H; i++){

	mov	rcx, rbx

; 68   : 			b[i] = c[j];

	mov	rdx, rbx
$LL155@median_fil:

; 62   : 		while(a_pos[i] < 1) k++;

	cmp	BYTE PTR r_b_p$[rbp+rcx-256], 1
	jl	$LL152@median_fil

; 63   : 		if(a[i+k] <= c[j]) {

	movzx	eax, BYTE PTR r_new$[rsp+rdx]
	lea	r8, QWORD PTR [rbx+rcx]
	movzx	r9d, BYTE PTR r_b$[rbp+r8-256]
	cmp	r9b, al
	jg	SHORT $LN150@median_fil

; 64   : 			b[i] = a[i+k];
; 65   : 			b_pos[i] = a_pos[i+k];

	movzx	eax, BYTE PTR r_b_p$[rbp+r8-256]
	mov	BYTE PTR r_a$[rbp+rcx-256], r9b

; 66   : 		}
; 67   : 		else {

	jmp	SHORT $LN1373@median_fil
$LN150@median_fil:

; 68   : 			b[i] = c[j];

	mov	BYTE PTR r_a$[rbp+rcx-256], al

; 69   : 			b_pos[i] = c_pos[j];

	movzx	eax, BYTE PTR r_new_p$[rsp+rdx]
	inc	rdx
$LN1373@median_fil:
	mov	BYTE PTR r_a_p$[rbp+rcx-256], al
	inc	rcx
	cmp	rcx, 25
	jl	SHORT $LL155@median_fil

; 9    : 	char pivot = nums[right], i, x;

	movzx	r11d, BYTE PTR g_new$[rsp+4]

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	xor	dl, dl
	xor	r8b, r8b
$LL192@median_fil:

; 14   : 		if (nums[x] <= pivot){

	lea	r9, QWORD PTR g_new$[rsp]
	movsx	rax, dl
	add	r9, rax
	movzx	r10d, BYTE PTR [r9]
	cmp	r10b, r11b
	jg	SHORT $LN191@median_fil

; 15   : 			SWAP(i, x);

	movsx	rax, r8b
	movzx	ecx, BYTE PTR g_new$[rsp+rax]
	mov	BYTE PTR g_new$[rsp+rax], r10b
	movzx	eax, r8b

; 16   : 			i++;

	lea	r8d, DWORD PTR [rdx+1]
	movzx	edx, al
	mov	BYTE PTR [r9], cl
$LN191@median_fil:

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	inc	dl
	cmp	dl, 4
	jl	SHORT $LL192@median_fil

; 17   : 		}
; 18   : 	}
; 19   : 	SWAP(i, right);

	movsx	rax, r8b
	lea	rcx, QWORD PTR g_new$[rsp]
	mov	r9d, 3
	add	rcx, rax
	movzx	eax, BYTE PTR g_new$[rsp+4]
	xor	r8d, r8d
	movzx	edx, BYTE PTR [rcx]
	mov	BYTE PTR [rcx], al
	lea	rcx, QWORD PTR g_new$[rsp]
	mov	BYTE PTR g_new$[rsp+4], dl
	lea	rdx, QWORD PTR g_new_p$[rsp]
	call	?quicksort@@YAXPEADPEACHH@Z		; quicksort

; 20   : 	return i;
; 21   : }
; 22   : 
; 23   : 
; 24   : void quicksort(char *nums, signed char* pos, int left, int right){
; 25   : 	//char new_p[5] = {21, 22, 23, 24, 25};
; 26   : 	signed char p;	//p is position of pivot in the partitioned array
; 27   : 	
; 28   : 	if (left < right){
; 29   : 		p = partition(nums, pos, left, right);
; 30   : 		quicksort(nums, pos, left, p - 1);
; 31   : 		quicksort(nums, pos, p + 1, right);
; 32   : 	}
; 33   : 	return;
; 34   : }
; 35   : /*
; 36   : int quickselect(char *nums, char* pos, int left, int right, int k){
; 37   : 	int p = partition(nums, new_p, left, right);	//p is position of pivot in the partitioned array
; 38   : 	int r;
; 39   : 	
; 40   : 	//k equals pivot got lucky
; 41   : 	if (p == k-1){
; 42   : 		r = nums[p];
; 43   : 	}
; 44   : 	//k less than pivot
; 45   : 	else if (k - 1 < p){
; 46   : 		r = quickselect(nums, new_p, left, p - 1, k);
; 47   : 	}
; 48   : 	//k greater than pivot
; 49   : 	else{
; 50   : 		r = quickselect(nums, new_p, p + 1, right, k);
; 51   : 	}
; 52   : 	pos = new_p;
; 53   : 	return r;
; 54   : }
; 55   : */
; 56   : 
; 57   : 
; 58   : void sort_and_merge(char* a, char* b, char* c, signed char* a_pos, signed char* b_pos, signed char* c_pos){
; 59   : 	int i, j, k;
; 60   : 	quicksort(c, c_pos, 0, FILTER_W-1);
; 61   : 	for(i = 0,j = 0, k = 0; i < FILTER_W * FILTER_H; i++){

	mov	rcx, rbx

; 68   : 			b[i] = c[j];

	mov	rdx, rbx
$LL183@median_fil:

; 62   : 		while(a_pos[i] < 1) k++;

	cmp	BYTE PTR g_b_p$[rbp+rcx-256], 1
	jl	$LL180@median_fil

; 63   : 		if(a[i+k] <= c[j]) {

	movzx	eax, BYTE PTR g_new$[rsp+rdx]
	lea	r8, QWORD PTR [rbx+rcx]
	movzx	r9d, BYTE PTR g_b$[rbp+r8-256]
	cmp	r9b, al
	jg	SHORT $LN178@median_fil

; 64   : 			b[i] = a[i+k];
; 65   : 			b_pos[i] = a_pos[i+k];

	movzx	eax, BYTE PTR g_b_p$[rbp+r8-256]
	mov	BYTE PTR g_a$[rbp+rcx-256], r9b

; 66   : 		}
; 67   : 		else {

	jmp	SHORT $LN1374@median_fil
$LN178@median_fil:

; 68   : 			b[i] = c[j];

	mov	BYTE PTR g_a$[rbp+rcx-256], al

; 69   : 			b_pos[i] = c_pos[j];

	movzx	eax, BYTE PTR g_new_p$[rsp+rdx]
	inc	rdx
$LN1374@median_fil:
	mov	BYTE PTR g_a_p$[rbp+rcx-256], al
	inc	rcx
	cmp	rcx, 25
	jl	SHORT $LL183@median_fil

; 9    : 	char pivot = nums[right], i, x;

	movzx	r11d, BYTE PTR b_new$[rsp+4]

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	xor	dl, dl
	xor	r8b, r8b
	npad	7
$LL220@median_fil:

; 14   : 		if (nums[x] <= pivot){

	lea	r9, QWORD PTR b_new$[rsp]
	movsx	rax, dl
	add	r9, rax
	movzx	r10d, BYTE PTR [r9]
	cmp	r10b, r11b
	jg	SHORT $LN219@median_fil

; 15   : 			SWAP(i, x);

	movsx	rax, r8b
	movzx	ecx, BYTE PTR b_new$[rsp+rax]
	mov	BYTE PTR b_new$[rsp+rax], r10b
	movzx	eax, r8b

; 16   : 			i++;

	lea	r8d, DWORD PTR [rdx+1]
	movzx	edx, al
	mov	BYTE PTR [r9], cl
$LN219@median_fil:

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	inc	dl
	cmp	dl, 4
	jl	SHORT $LL220@median_fil

; 17   : 		}
; 18   : 	}
; 19   : 	SWAP(i, right);

	movsx	rax, r8b
	lea	rcx, QWORD PTR b_new$[rsp]
	mov	r9d, 3
	add	rcx, rax
	movzx	eax, BYTE PTR b_new$[rsp+4]
	xor	r8d, r8d
	movzx	edx, BYTE PTR [rcx]
	mov	BYTE PTR [rcx], al
	lea	rcx, QWORD PTR b_new$[rsp]
	mov	BYTE PTR b_new$[rsp+4], dl
	lea	rdx, QWORD PTR b_new_p$[rsp]
	call	?quicksort@@YAXPEADPEACHH@Z		; quicksort

; 20   : 	return i;
; 21   : }
; 22   : 
; 23   : 
; 24   : void quicksort(char *nums, signed char* pos, int left, int right){
; 25   : 	//char new_p[5] = {21, 22, 23, 24, 25};
; 26   : 	signed char p;	//p is position of pivot in the partitioned array
; 27   : 	
; 28   : 	if (left < right){
; 29   : 		p = partition(nums, pos, left, right);
; 30   : 		quicksort(nums, pos, left, p - 1);
; 31   : 		quicksort(nums, pos, p + 1, right);
; 32   : 	}
; 33   : 	return;
; 34   : }
; 35   : /*
; 36   : int quickselect(char *nums, char* pos, int left, int right, int k){
; 37   : 	int p = partition(nums, new_p, left, right);	//p is position of pivot in the partitioned array
; 38   : 	int r;
; 39   : 	
; 40   : 	//k equals pivot got lucky
; 41   : 	if (p == k-1){
; 42   : 		r = nums[p];
; 43   : 	}
; 44   : 	//k less than pivot
; 45   : 	else if (k - 1 < p){
; 46   : 		r = quickselect(nums, new_p, left, p - 1, k);
; 47   : 	}
; 48   : 	//k greater than pivot
; 49   : 	else{
; 50   : 		r = quickselect(nums, new_p, p + 1, right, k);
; 51   : 	}
; 52   : 	pos = new_p;
; 53   : 	return r;
; 54   : }
; 55   : */
; 56   : 
; 57   : 
; 58   : void sort_and_merge(char* a, char* b, char* c, signed char* a_pos, signed char* b_pos, signed char* c_pos){
; 59   : 	int i, j, k;
; 60   : 	quicksort(c, c_pos, 0, FILTER_W-1);
; 61   : 	for(i = 0,j = 0, k = 0; i < FILTER_W * FILTER_H; i++){

	mov	rcx, rbx

; 68   : 			b[i] = c[j];

	mov	rdx, rbx
$LL211@median_fil:

; 62   : 		while(a_pos[i] < 1) k++;

	cmp	BYTE PTR b_b_p$[rbp+rcx-256], 1
	jl	$LL208@median_fil

; 63   : 		if(a[i+k] <= c[j]) {

	movzx	eax, BYTE PTR b_new$[rsp+rdx]
	lea	r8, QWORD PTR [rbx+rcx]
	movzx	r9d, BYTE PTR b_b$[rbp+r8-256]
	cmp	r9b, al
	jg	SHORT $LN206@median_fil

; 64   : 			b[i] = a[i+k];
; 65   : 			b_pos[i] = a_pos[i+k];

	movzx	eax, BYTE PTR b_b_p$[rbp+r8-256]
	mov	BYTE PTR b_a$[rbp+rcx-256], r9b

; 66   : 		}
; 67   : 		else {

	jmp	SHORT $LN1375@median_fil
$LN206@median_fil:

; 68   : 			b[i] = c[j];

	mov	BYTE PTR b_a$[rbp+rcx-256], al

; 69   : 			b_pos[i] = c_pos[j];

	movzx	eax, BYTE PTR b_new_p$[rsp+rdx]
	inc	rdx
$LN1375@median_fil:
	mov	BYTE PTR b_a_p$[rsp+rcx], al
	inc	rcx
	cmp	rcx, 25
	jl	SHORT $LL211@median_fil

; 255  : 	}
; 256  : 	
; 257  : 	//Sorting new values and merging the 2 tables
; 258  : 	sort_and_merge(r_b, r_a, r_new, r_b_p, r_a_p, r_new_p);
; 259  : 	sort_and_merge(g_b, g_a, g_new, g_b_p, g_a_p, g_new_p);
; 260  : 	sort_and_merge(b_b, b_a, b_new, b_b_p, b_a_p, b_new_p);
; 261  : 	
; 262  : 	
; 263  : //---------------	
; 264  : //Image processing
; 265  : //---------------
; 266  : 
; 267  : 	base = (imgFOffsetW) * 4;	//Setting up base addresses

	mov	QWORD PTR [rsp+560], r12
	mov	QWORD PTR [rsp+576], r13
	mov	esi, 24
	mov	QWORD PTR [rsp+584], r15

; 268  : 	base_out = 0;

	mov	edi, ebx

; 269  : 	
; 270  : 	while(Y < imgHeight){

	test	r14d, r14d
	jle	$LN1212@median_fil
	movzx	r15d, BYTE PTR r_a$[rbp-244]
	movzx	r12d, BYTE PTR g_a$[rbp-244]
	movzx	r13d, BYTE PTR b_a$[rbp-244]
	mov	ecx, ebx
	npad	6
$LL65@median_fil:

; 271  : 		for(X = 0; X < imgWidth; X ++){

	cmp	DWORD PTR imgWidth$GSCopy$1$[rsp], 0
	mov	r14d, ebx
	jle	$LN825@median_fil
	movsxd	rsi, esi
	movsxd	rdi, edi
	npad	12
$LL63@median_fil:

; 272  : 			//Horizontal part, forward
; 273  : 			
; 274  : 			//Updating A positions
; 275  : 			for(i = 0; i < FILTER_H * FILTER_W; i++){

	mov	rax, rbx
	mov	ecx, 25
	npad	8
$LL60@median_fil:

; 276  : 				r_a_p[i] = r_a_p[i] - 5;

	add	BYTE PTR r_a_p$[rbp+rax-256], -5

; 277  : 				g_a_p[i] = g_a_p[i] - 5;

	add	BYTE PTR g_a_p$[rbp+rax-256], -5

; 278  : 				b_a_p[i] = b_a_p[i] - 5;

	add	BYTE PTR b_a_p$[rsp+rax], -5
	lea	rax, QWORD PTR [rax+1]
	dec	rcx
	jne	SHORT $LL60@median_fil

; 279  : 			}
; 280  : 			
; 281  : 			//Reading new values from the original image and getting new positions
; 282  : 			for(i = 0; i < FILTER_H; i++){

	mov	rdx, QWORD PTR imgSrc$[rbp-256]
	mov	r15, QWORD PTR tv12264[rsp]
	mov	r8d, ebx
	add	rdx, 2

; 286  : 
; 287  : 				r_new[i] = imgSrc[base + i * imgWidthF * 4];

	mov	rcx, rbx
	add	rdx, rsi
$LL57@median_fil:

; 279  : 			}
; 280  : 			
; 281  : 			//Reading new values from the original image and getting new positions
; 282  : 			for(i = 0; i < FILTER_H; i++){

	lea	eax, DWORD PTR [r8+20]
	inc	r8d
	lea	rcx, QWORD PTR [rcx+1]

; 283  : 				r_new_p[i] = FILTER_H * (FILTER_W - 1) + i;

	mov	BYTE PTR r_new_p$[rsp+rcx-1], al

; 284  : 				g_new_p[i] = FILTER_H * (FILTER_W - 1) + i;

	mov	BYTE PTR g_new_p$[rsp+rcx-1], al

; 285  : 				b_new_p[i] = FILTER_H * (FILTER_W - 1) + i;

	mov	BYTE PTR b_new_p$[rsp+rcx-1], al

; 286  : 
; 287  : 				r_new[i] = imgSrc[base + i * imgWidthF * 4];

	movzx	eax, BYTE PTR [rdx-2]
	mov	BYTE PTR r_new$[rsp+rcx-1], al

; 288  : 				g_new[i] = imgSrc[base + i * imgWidthF * 4 + 1];

	movzx	eax, BYTE PTR [rdx-1]
	mov	BYTE PTR g_new$[rsp+rcx-1], al

; 289  : 				b_new[i] = imgSrc[base + i * imgWidthF * 4 + 2];

	movzx	eax, BYTE PTR [rdx]
	add	rdx, r15
	mov	BYTE PTR b_new$[rsp+rcx-1], al
	cmp	r8d, 5
	jl	SHORT $LL57@median_fil
	movzx	r15d, BYTE PTR r_a$[rbp-244]

; 9    : 	char pivot = nums[right], i, x;

	movzx	r11d, BYTE PTR r_new$[rsp+4]

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	xor	dl, dl
	xor	r8b, r8b
	npad	8
$LL248@median_fil:

; 14   : 		if (nums[x] <= pivot){

	lea	r9, QWORD PTR r_new$[rsp]
	movsx	rax, dl
	add	r9, rax
	movzx	r10d, BYTE PTR [r9]
	cmp	r10b, r11b
	jg	SHORT $LN247@median_fil

; 15   : 			SWAP(i, x);

	movsx	rax, r8b
	movzx	ecx, BYTE PTR r_new$[rsp+rax]
	mov	BYTE PTR r_new$[rsp+rax], r10b
	movzx	eax, r8b

; 16   : 			i++;

	lea	r8d, DWORD PTR [rdx+1]
	movzx	edx, al
	mov	BYTE PTR [r9], cl
$LN247@median_fil:

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	inc	dl
	cmp	dl, 4
	jl	SHORT $LL248@median_fil

; 17   : 		}
; 18   : 	}
; 19   : 	SWAP(i, right);

	movsx	rax, r8b
	lea	rcx, QWORD PTR r_new$[rsp]
	mov	r9d, 3
	add	rcx, rax
	movzx	eax, BYTE PTR r_new$[rsp+4]
	xor	r8d, r8d
	movzx	edx, BYTE PTR [rcx]
	mov	BYTE PTR [rcx], al
	lea	rcx, QWORD PTR r_new$[rsp]
	mov	BYTE PTR r_new$[rsp+4], dl
	lea	rdx, QWORD PTR r_new_p$[rsp]
	call	?quicksort@@YAXPEADPEACHH@Z		; quicksort

; 20   : 	return i;
; 21   : }
; 22   : 
; 23   : 
; 24   : void quicksort(char *nums, signed char* pos, int left, int right){
; 25   : 	//char new_p[5] = {21, 22, 23, 24, 25};
; 26   : 	signed char p;	//p is position of pivot in the partitioned array
; 27   : 	
; 28   : 	if (left < right){
; 29   : 		p = partition(nums, pos, left, right);
; 30   : 		quicksort(nums, pos, left, p - 1);
; 31   : 		quicksort(nums, pos, p + 1, right);
; 32   : 	}
; 33   : 	return;
; 34   : }
; 35   : /*
; 36   : int quickselect(char *nums, char* pos, int left, int right, int k){
; 37   : 	int p = partition(nums, new_p, left, right);	//p is position of pivot in the partitioned array
; 38   : 	int r;
; 39   : 	
; 40   : 	//k equals pivot got lucky
; 41   : 	if (p == k-1){
; 42   : 		r = nums[p];
; 43   : 	}
; 44   : 	//k less than pivot
; 45   : 	else if (k - 1 < p){
; 46   : 		r = quickselect(nums, new_p, left, p - 1, k);
; 47   : 	}
; 48   : 	//k greater than pivot
; 49   : 	else{
; 50   : 		r = quickselect(nums, new_p, p + 1, right, k);
; 51   : 	}
; 52   : 	pos = new_p;
; 53   : 	return r;
; 54   : }
; 55   : */
; 56   : 
; 57   : 
; 58   : void sort_and_merge(char* a, char* b, char* c, signed char* a_pos, signed char* b_pos, signed char* c_pos){
; 59   : 	int i, j, k;
; 60   : 	quicksort(c, c_pos, 0, FILTER_W-1);
; 61   : 	for(i = 0,j = 0, k = 0; i < FILTER_W * FILTER_H; i++){

	mov	rcx, rbx

; 68   : 			b[i] = c[j];

	mov	rdx, rbx
$LL239@median_fil:

; 62   : 		while(a_pos[i] < 1) k++;

	cmp	BYTE PTR r_a_p$[rbp+rcx-256], 1
	jl	$LL236@median_fil

; 63   : 		if(a[i+k] <= c[j]) {

	movzx	eax, BYTE PTR r_new$[rsp+rdx]
	lea	r8, QWORD PTR [rbx+rcx]
	movzx	r9d, BYTE PTR r_a$[rbp+r8-256]
	cmp	r9b, al
	jg	SHORT $LN234@median_fil

; 64   : 			b[i] = a[i+k];
; 65   : 			b_pos[i] = a_pos[i+k];

	movzx	eax, BYTE PTR r_a_p$[rbp+r8-256]
	mov	BYTE PTR r_b$[rbp+rcx-256], r9b

; 66   : 		}
; 67   : 		else {

	jmp	SHORT $LN1376@median_fil
$LN234@median_fil:

; 68   : 			b[i] = c[j];

	mov	BYTE PTR r_b$[rbp+rcx-256], al

; 69   : 			b_pos[i] = c_pos[j];

	movzx	eax, BYTE PTR r_new_p$[rsp+rdx]
	inc	rdx
$LN1376@median_fil:
	mov	BYTE PTR r_b_p$[rbp+rcx-256], al
	inc	rcx
	cmp	rcx, 25
	jl	SHORT $LL239@median_fil

; 9    : 	char pivot = nums[right], i, x;

	movzx	r11d, BYTE PTR g_new$[rsp+4]

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	xor	dl, dl
	xor	r8b, r8b
$LL276@median_fil:

; 14   : 		if (nums[x] <= pivot){

	lea	r9, QWORD PTR g_new$[rsp]
	movsx	rax, dl
	add	r9, rax
	movzx	r10d, BYTE PTR [r9]
	cmp	r10b, r11b
	jg	SHORT $LN275@median_fil

; 15   : 			SWAP(i, x);

	movsx	rax, r8b
	movzx	ecx, BYTE PTR g_new$[rsp+rax]
	mov	BYTE PTR g_new$[rsp+rax], r10b
	movzx	eax, r8b

; 16   : 			i++;

	lea	r8d, DWORD PTR [rdx+1]
	movzx	edx, al
	mov	BYTE PTR [r9], cl
$LN275@median_fil:

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	inc	dl
	cmp	dl, 4
	jl	SHORT $LL276@median_fil

; 17   : 		}
; 18   : 	}
; 19   : 	SWAP(i, right);

	movsx	rax, r8b
	lea	rcx, QWORD PTR g_new$[rsp]
	mov	r9d, 3
	add	rcx, rax
	movzx	eax, BYTE PTR g_new$[rsp+4]
	xor	r8d, r8d
	movzx	edx, BYTE PTR [rcx]
	mov	BYTE PTR [rcx], al
	lea	rcx, QWORD PTR g_new$[rsp]
	mov	BYTE PTR g_new$[rsp+4], dl
	lea	rdx, QWORD PTR g_new_p$[rsp]
	call	?quicksort@@YAXPEADPEACHH@Z		; quicksort

; 20   : 	return i;
; 21   : }
; 22   : 
; 23   : 
; 24   : void quicksort(char *nums, signed char* pos, int left, int right){
; 25   : 	//char new_p[5] = {21, 22, 23, 24, 25};
; 26   : 	signed char p;	//p is position of pivot in the partitioned array
; 27   : 	
; 28   : 	if (left < right){
; 29   : 		p = partition(nums, pos, left, right);
; 30   : 		quicksort(nums, pos, left, p - 1);
; 31   : 		quicksort(nums, pos, p + 1, right);
; 32   : 	}
; 33   : 	return;
; 34   : }
; 35   : /*
; 36   : int quickselect(char *nums, char* pos, int left, int right, int k){
; 37   : 	int p = partition(nums, new_p, left, right);	//p is position of pivot in the partitioned array
; 38   : 	int r;
; 39   : 	
; 40   : 	//k equals pivot got lucky
; 41   : 	if (p == k-1){
; 42   : 		r = nums[p];
; 43   : 	}
; 44   : 	//k less than pivot
; 45   : 	else if (k - 1 < p){
; 46   : 		r = quickselect(nums, new_p, left, p - 1, k);
; 47   : 	}
; 48   : 	//k greater than pivot
; 49   : 	else{
; 50   : 		r = quickselect(nums, new_p, p + 1, right, k);
; 51   : 	}
; 52   : 	pos = new_p;
; 53   : 	return r;
; 54   : }
; 55   : */
; 56   : 
; 57   : 
; 58   : void sort_and_merge(char* a, char* b, char* c, signed char* a_pos, signed char* b_pos, signed char* c_pos){
; 59   : 	int i, j, k;
; 60   : 	quicksort(c, c_pos, 0, FILTER_W-1);
; 61   : 	for(i = 0,j = 0, k = 0; i < FILTER_W * FILTER_H; i++){

	mov	rcx, rbx

; 68   : 			b[i] = c[j];

	mov	rdx, rbx
$LL267@median_fil:

; 62   : 		while(a_pos[i] < 1) k++;

	cmp	BYTE PTR g_a_p$[rbp+rcx-256], 1
	jl	$LL264@median_fil

; 63   : 		if(a[i+k] <= c[j]) {

	movzx	eax, BYTE PTR g_new$[rsp+rdx]
	lea	r8, QWORD PTR [rbx+rcx]
	movzx	r9d, BYTE PTR g_a$[rbp+r8-256]
	cmp	r9b, al
	jg	SHORT $LN262@median_fil

; 64   : 			b[i] = a[i+k];
; 65   : 			b_pos[i] = a_pos[i+k];

	movzx	eax, BYTE PTR g_a_p$[rbp+r8-256]
	mov	BYTE PTR g_b$[rbp+rcx-256], r9b

; 66   : 		}
; 67   : 		else {

	jmp	SHORT $LN1377@median_fil
$LN262@median_fil:

; 68   : 			b[i] = c[j];

	mov	BYTE PTR g_b$[rbp+rcx-256], al

; 69   : 			b_pos[i] = c_pos[j];

	movzx	eax, BYTE PTR g_new_p$[rsp+rdx]
	inc	rdx
$LN1377@median_fil:
	mov	BYTE PTR g_b_p$[rbp+rcx-256], al
	inc	rcx
	cmp	rcx, 25
	jl	SHORT $LL267@median_fil

; 9    : 	char pivot = nums[right], i, x;

	movzx	r11d, BYTE PTR b_new$[rsp+4]

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	xor	dl, dl
	xor	r8b, r8b
	npad	7
$LL304@median_fil:

; 14   : 		if (nums[x] <= pivot){

	lea	r9, QWORD PTR b_new$[rsp]
	movsx	rax, dl
	add	r9, rax
	movzx	r10d, BYTE PTR [r9]
	cmp	r10b, r11b
	jg	SHORT $LN303@median_fil

; 15   : 			SWAP(i, x);

	movsx	rax, r8b
	movzx	ecx, BYTE PTR b_new$[rsp+rax]
	mov	BYTE PTR b_new$[rsp+rax], r10b
	movzx	eax, r8b

; 16   : 			i++;

	lea	r8d, DWORD PTR [rdx+1]
	movzx	edx, al
	mov	BYTE PTR [r9], cl
$LN303@median_fil:

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	inc	dl
	cmp	dl, 4
	jl	SHORT $LL304@median_fil

; 17   : 		}
; 18   : 	}
; 19   : 	SWAP(i, right);

	movsx	rax, r8b
	lea	rcx, QWORD PTR b_new$[rsp]
	mov	r9d, 3
	add	rcx, rax
	movzx	eax, BYTE PTR b_new$[rsp+4]
	xor	r8d, r8d
	movzx	edx, BYTE PTR [rcx]
	mov	BYTE PTR [rcx], al
	lea	rcx, QWORD PTR b_new$[rsp]
	mov	BYTE PTR b_new$[rsp+4], dl
	lea	rdx, QWORD PTR b_new_p$[rsp]
	call	?quicksort@@YAXPEADPEACHH@Z		; quicksort

; 20   : 	return i;
; 21   : }
; 22   : 
; 23   : 
; 24   : void quicksort(char *nums, signed char* pos, int left, int right){
; 25   : 	//char new_p[5] = {21, 22, 23, 24, 25};
; 26   : 	signed char p;	//p is position of pivot in the partitioned array
; 27   : 	
; 28   : 	if (left < right){
; 29   : 		p = partition(nums, pos, left, right);
; 30   : 		quicksort(nums, pos, left, p - 1);
; 31   : 		quicksort(nums, pos, p + 1, right);
; 32   : 	}
; 33   : 	return;
; 34   : }
; 35   : /*
; 36   : int quickselect(char *nums, char* pos, int left, int right, int k){
; 37   : 	int p = partition(nums, new_p, left, right);	//p is position of pivot in the partitioned array
; 38   : 	int r;
; 39   : 	
; 40   : 	//k equals pivot got lucky
; 41   : 	if (p == k-1){
; 42   : 		r = nums[p];
; 43   : 	}
; 44   : 	//k less than pivot
; 45   : 	else if (k - 1 < p){
; 46   : 		r = quickselect(nums, new_p, left, p - 1, k);
; 47   : 	}
; 48   : 	//k greater than pivot
; 49   : 	else{
; 50   : 		r = quickselect(nums, new_p, p + 1, right, k);
; 51   : 	}
; 52   : 	pos = new_p;
; 53   : 	return r;
; 54   : }
; 55   : */
; 56   : 
; 57   : 
; 58   : void sort_and_merge(char* a, char* b, char* c, signed char* a_pos, signed char* b_pos, signed char* c_pos){
; 59   : 	int i, j, k;
; 60   : 	quicksort(c, c_pos, 0, FILTER_W-1);
; 61   : 	for(i = 0,j = 0, k = 0; i < FILTER_W * FILTER_H; i++){

	mov	rcx, rbx

; 68   : 			b[i] = c[j];

	mov	rdx, rbx
$LL295@median_fil:

; 62   : 		while(a_pos[i] < 1) k++;

	cmp	BYTE PTR b_a_p$[rsp+rcx], 1
	jl	$LL292@median_fil

; 63   : 		if(a[i+k] <= c[j]) {

	movzx	eax, BYTE PTR b_new$[rsp+rdx]
	lea	r8, QWORD PTR [rbx+rcx]
	movzx	r9d, BYTE PTR b_a$[rbp+r8-256]
	cmp	r9b, al
	jg	SHORT $LN290@median_fil

; 64   : 			b[i] = a[i+k];
; 65   : 			b_pos[i] = a_pos[i+k];

	movzx	eax, BYTE PTR b_a_p$[rsp+r8]
	mov	BYTE PTR b_b$[rbp+rcx-256], r9b

; 66   : 		}
; 67   : 		else {

	jmp	SHORT $LN1378@median_fil
$LN290@median_fil:

; 68   : 			b[i] = c[j];

	mov	BYTE PTR b_b$[rbp+rcx-256], al

; 69   : 			b_pos[i] = c_pos[j];

	movzx	eax, BYTE PTR b_new_p$[rsp+rdx]
	inc	rdx
$LN1378@median_fil:
	mov	BYTE PTR b_b_p$[rbp+rcx-256], al
	inc	rcx
	cmp	rcx, 25
	jl	SHORT $LL295@median_fil

; 290  : 			}
; 291  : 			
; 292  : 			//Sorting new values and merging the 2 tables
; 293  : 			//First from A+C->B then B+C->A
; 294  : 			sort_and_merge(r_a, r_b, r_new, r_a_p, r_b_p, r_new_p);
; 295  : 			sort_and_merge(g_a, g_b, g_new, g_a_p, g_b_p, g_new_p);
; 296  : 			sort_and_merge(b_a, b_b, b_new, b_a_p, b_b_p, b_new_p);
; 297  : 			
; 298  : 			//Writing out calculated pixel
; 299  : 			imgDst[base_out] 		= r_b[12];

	mov	rdx, QWORD PTR imgDst$GSCopy$1$[rsp]
	movzx	eax, BYTE PTR r_b$[rbp-244]

; 300  : 			imgDst[base_out + 1]	= g_b[12];
; 301  : 			imgDst[base_out + 2]	= b_b[12];
; 302  : 			
; 303  : 			//Updating base addresses
; 304  : 			base += 4;

	add	rsi, 4
	mov	BYTE PTR [rdi+rdx], al
	movzx	eax, BYTE PTR g_b$[rbp-244]
	mov	BYTE PTR [rdx+rdi+1], al
	movzx	eax, BYTE PTR b_b$[rbp-244]
	mov	BYTE PTR [rdx+rdi+2], al

; 305  : 			base_out += 4;
; 306  : 			
; 307  : 			if(X == imgWidth) break;	//Break if the edge is reached

	cmp	r14d, DWORD PTR imgWidth$GSCopy$1$[rsp]
	je	$LN1350@median_fil

; 308  : 			else X++;
; 309  : 			
; 310  : 			//Updating B positions
; 311  : 			for(i = 0; i < FILTER_H * FILTER_W; i++){

	mov	rax, rbx
	mov	ecx, 25
$LL52@median_fil:

; 312  : 				r_b_p[i] = r_b_p[i] - 5;

	add	BYTE PTR r_b_p$[rbp+rax-256], -5

; 313  : 				g_b_p[i] = g_b_p[i] - 5;

	add	BYTE PTR g_b_p$[rbp+rax-256], -5

; 314  : 				b_b_p[i] = b_b_p[i] - 5;

	add	BYTE PTR b_b_p$[rbp+rax-256], -5
	lea	rax, QWORD PTR [rax+1]
	dec	rcx
	jne	SHORT $LL52@median_fil

; 315  : 			}
; 316  : 			
; 317  : 			//Reading new values from the original image and getting new positions
; 318  : 			for(i = 0; i < FILTER_H; i++){

	mov	rdx, QWORD PTR imgSrc$[rbp-256]
	mov	r8d, ebx

; 322  : 
; 323  : 				r_new[i] = imgSrc[base + i * imgWidthF * 4];

	mov	rcx, rbx
	mov	rbx, QWORD PTR tv12264[rsp]
	add	rdx, 2
	add	rdx, rsi
	npad	14
$LL49@median_fil:

; 315  : 			}
; 316  : 			
; 317  : 			//Reading new values from the original image and getting new positions
; 318  : 			for(i = 0; i < FILTER_H; i++){

	lea	eax, DWORD PTR [r8+20]
	inc	r8d
	lea	rcx, QWORD PTR [rcx+1]

; 319  : 				r_new_p[i] = FILTER_H * (FILTER_W - 1) + i;

	mov	BYTE PTR r_new_p$[rsp+rcx-1], al

; 320  : 				g_new_p[i] = FILTER_H * (FILTER_W - 1) + i;

	mov	BYTE PTR g_new_p$[rsp+rcx-1], al

; 321  : 				b_new_p[i] = FILTER_H * (FILTER_W - 1) + i;

	mov	BYTE PTR b_new_p$[rsp+rcx-1], al

; 322  : 
; 323  : 				r_new[i] = imgSrc[base + i * imgWidthF * 4];

	movzx	eax, BYTE PTR [rdx-2]
	mov	BYTE PTR r_new$[rsp+rcx-1], al

; 324  : 				g_new[i] = imgSrc[base + i * imgWidthF * 4 + 1];

	movzx	eax, BYTE PTR [rdx-1]
	mov	BYTE PTR g_new$[rsp+rcx-1], al

; 325  : 				b_new[i] = imgSrc[base + i * imgWidthF * 4 + 2];

	movzx	eax, BYTE PTR [rdx]
	add	rdx, rbx
	mov	BYTE PTR b_new$[rsp+rcx-1], al
	cmp	r8d, 5
	jl	SHORT $LL49@median_fil

; 9    : 	char pivot = nums[right], i, x;

	movzx	r11d, BYTE PTR r_new$[rsp+4]
	xor	ebx, ebx

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	xor	dl, dl
	xor	r8b, r8b
	npad	12
$LL332@median_fil:

; 14   : 		if (nums[x] <= pivot){

	lea	r9, QWORD PTR r_new$[rsp]
	movsx	rax, dl
	add	r9, rax
	movzx	r10d, BYTE PTR [r9]
	cmp	r10b, r11b
	jg	SHORT $LN331@median_fil

; 15   : 			SWAP(i, x);

	movsx	rax, r8b
	movzx	ecx, BYTE PTR r_new$[rsp+rax]
	mov	BYTE PTR r_new$[rsp+rax], r10b
	movzx	eax, r8b

; 16   : 			i++;

	lea	r8d, DWORD PTR [rdx+1]
	movzx	edx, al
	mov	BYTE PTR [r9], cl
$LN331@median_fil:

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	inc	dl
	cmp	dl, 4
	jl	SHORT $LL332@median_fil

; 17   : 		}
; 18   : 	}
; 19   : 	SWAP(i, right);

	movsx	rax, r8b
	lea	rcx, QWORD PTR r_new$[rsp]
	mov	r9d, 3
	add	rcx, rax
	movzx	eax, BYTE PTR r_new$[rsp+4]
	xor	r8d, r8d
	movzx	edx, BYTE PTR [rcx]
	mov	BYTE PTR [rcx], al
	lea	rcx, QWORD PTR r_new$[rsp]
	mov	BYTE PTR r_new$[rsp+4], dl
	lea	rdx, QWORD PTR r_new_p$[rsp]
	call	?quicksort@@YAXPEADPEACHH@Z		; quicksort

; 20   : 	return i;
; 21   : }
; 22   : 
; 23   : 
; 24   : void quicksort(char *nums, signed char* pos, int left, int right){
; 25   : 	//char new_p[5] = {21, 22, 23, 24, 25};
; 26   : 	signed char p;	//p is position of pivot in the partitioned array
; 27   : 	
; 28   : 	if (left < right){
; 29   : 		p = partition(nums, pos, left, right);
; 30   : 		quicksort(nums, pos, left, p - 1);
; 31   : 		quicksort(nums, pos, p + 1, right);
; 32   : 	}
; 33   : 	return;
; 34   : }
; 35   : /*
; 36   : int quickselect(char *nums, char* pos, int left, int right, int k){
; 37   : 	int p = partition(nums, new_p, left, right);	//p is position of pivot in the partitioned array
; 38   : 	int r;
; 39   : 	
; 40   : 	//k equals pivot got lucky
; 41   : 	if (p == k-1){
; 42   : 		r = nums[p];
; 43   : 	}
; 44   : 	//k less than pivot
; 45   : 	else if (k - 1 < p){
; 46   : 		r = quickselect(nums, new_p, left, p - 1, k);
; 47   : 	}
; 48   : 	//k greater than pivot
; 49   : 	else{
; 50   : 		r = quickselect(nums, new_p, p + 1, right, k);
; 51   : 	}
; 52   : 	pos = new_p;
; 53   : 	return r;
; 54   : }
; 55   : */
; 56   : 
; 57   : 
; 58   : void sort_and_merge(char* a, char* b, char* c, signed char* a_pos, signed char* b_pos, signed char* c_pos){
; 59   : 	int i, j, k;
; 60   : 	quicksort(c, c_pos, 0, FILTER_W-1);
; 61   : 	for(i = 0,j = 0, k = 0; i < FILTER_W * FILTER_H; i++){

	mov	rcx, rbx

; 68   : 			b[i] = c[j];

	mov	rdx, rbx
$LL323@median_fil:

; 62   : 		while(a_pos[i] < 1) k++;

	cmp	BYTE PTR r_b_p$[rbp+rcx-256], 1
	jl	$LL320@median_fil

; 63   : 		if(a[i+k] <= c[j]) {

	movzx	eax, BYTE PTR r_new$[rsp+rdx]
	lea	r8, QWORD PTR [rbx+rcx]
	movzx	r9d, BYTE PTR r_b$[rbp+r8-256]
	cmp	r9b, al
	jg	SHORT $LN318@median_fil

; 64   : 			b[i] = a[i+k];
; 65   : 			b_pos[i] = a_pos[i+k];

	movzx	eax, BYTE PTR r_b_p$[rbp+r8-256]
	mov	BYTE PTR r_a$[rbp+rcx-256], r9b

; 66   : 		}
; 67   : 		else {

	jmp	SHORT $LN1379@median_fil
$LN318@median_fil:

; 68   : 			b[i] = c[j];

	mov	BYTE PTR r_a$[rbp+rcx-256], al

; 69   : 			b_pos[i] = c_pos[j];

	movzx	eax, BYTE PTR r_new_p$[rsp+rdx]
	inc	rdx
$LN1379@median_fil:
	mov	BYTE PTR r_a_p$[rbp+rcx-256], al
	inc	rcx
	cmp	rcx, 25
	jl	SHORT $LL323@median_fil

; 9    : 	char pivot = nums[right], i, x;

	movzx	r11d, BYTE PTR g_new$[rsp+4]

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	xor	dl, dl
	xor	r8b, r8b
$LL360@median_fil:

; 14   : 		if (nums[x] <= pivot){

	lea	r9, QWORD PTR g_new$[rsp]
	movsx	rax, dl
	add	r9, rax
	movzx	r10d, BYTE PTR [r9]
	cmp	r10b, r11b
	jg	SHORT $LN359@median_fil

; 15   : 			SWAP(i, x);

	movsx	rax, r8b
	movzx	ecx, BYTE PTR g_new$[rsp+rax]
	mov	BYTE PTR g_new$[rsp+rax], r10b
	movzx	eax, r8b

; 16   : 			i++;

	lea	r8d, DWORD PTR [rdx+1]
	movzx	edx, al
	mov	BYTE PTR [r9], cl
$LN359@median_fil:

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	inc	dl
	cmp	dl, 4
	jl	SHORT $LL360@median_fil

; 17   : 		}
; 18   : 	}
; 19   : 	SWAP(i, right);

	movsx	rax, r8b
	lea	rcx, QWORD PTR g_new$[rsp]
	mov	r9d, 3
	add	rcx, rax
	movzx	eax, BYTE PTR g_new$[rsp+4]
	xor	r8d, r8d
	movzx	edx, BYTE PTR [rcx]
	mov	BYTE PTR [rcx], al
	lea	rcx, QWORD PTR g_new$[rsp]
	mov	BYTE PTR g_new$[rsp+4], dl
	lea	rdx, QWORD PTR g_new_p$[rsp]
	call	?quicksort@@YAXPEADPEACHH@Z		; quicksort

; 20   : 	return i;
; 21   : }
; 22   : 
; 23   : 
; 24   : void quicksort(char *nums, signed char* pos, int left, int right){
; 25   : 	//char new_p[5] = {21, 22, 23, 24, 25};
; 26   : 	signed char p;	//p is position of pivot in the partitioned array
; 27   : 	
; 28   : 	if (left < right){
; 29   : 		p = partition(nums, pos, left, right);
; 30   : 		quicksort(nums, pos, left, p - 1);
; 31   : 		quicksort(nums, pos, p + 1, right);
; 32   : 	}
; 33   : 	return;
; 34   : }
; 35   : /*
; 36   : int quickselect(char *nums, char* pos, int left, int right, int k){
; 37   : 	int p = partition(nums, new_p, left, right);	//p is position of pivot in the partitioned array
; 38   : 	int r;
; 39   : 	
; 40   : 	//k equals pivot got lucky
; 41   : 	if (p == k-1){
; 42   : 		r = nums[p];
; 43   : 	}
; 44   : 	//k less than pivot
; 45   : 	else if (k - 1 < p){
; 46   : 		r = quickselect(nums, new_p, left, p - 1, k);
; 47   : 	}
; 48   : 	//k greater than pivot
; 49   : 	else{
; 50   : 		r = quickselect(nums, new_p, p + 1, right, k);
; 51   : 	}
; 52   : 	pos = new_p;
; 53   : 	return r;
; 54   : }
; 55   : */
; 56   : 
; 57   : 
; 58   : void sort_and_merge(char* a, char* b, char* c, signed char* a_pos, signed char* b_pos, signed char* c_pos){
; 59   : 	int i, j, k;
; 60   : 	quicksort(c, c_pos, 0, FILTER_W-1);
; 61   : 	for(i = 0,j = 0, k = 0; i < FILTER_W * FILTER_H; i++){

	mov	rcx, rbx

; 68   : 			b[i] = c[j];

	mov	rdx, rbx
$LL351@median_fil:

; 62   : 		while(a_pos[i] < 1) k++;

	cmp	BYTE PTR g_b_p$[rbp+rcx-256], 1
	jl	$LL348@median_fil

; 63   : 		if(a[i+k] <= c[j]) {

	movzx	eax, BYTE PTR g_new$[rsp+rdx]
	lea	r8, QWORD PTR [rbx+rcx]
	movzx	r9d, BYTE PTR g_b$[rbp+r8-256]
	cmp	r9b, al
	jg	SHORT $LN346@median_fil

; 64   : 			b[i] = a[i+k];
; 65   : 			b_pos[i] = a_pos[i+k];

	movzx	eax, BYTE PTR g_b_p$[rbp+r8-256]
	mov	BYTE PTR g_a$[rbp+rcx-256], r9b

; 66   : 		}
; 67   : 		else {

	jmp	SHORT $LN1380@median_fil
$LN346@median_fil:

; 68   : 			b[i] = c[j];

	mov	BYTE PTR g_a$[rbp+rcx-256], al

; 69   : 			b_pos[i] = c_pos[j];

	movzx	eax, BYTE PTR g_new_p$[rsp+rdx]
	inc	rdx
$LN1380@median_fil:
	mov	BYTE PTR g_a_p$[rbp+rcx-256], al
	inc	rcx
	cmp	rcx, 25
	jl	SHORT $LL351@median_fil

; 9    : 	char pivot = nums[right], i, x;

	movzx	r11d, BYTE PTR b_new$[rsp+4]

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	xor	dl, dl
	xor	r8b, r8b
	npad	7
$LL388@median_fil:

; 14   : 		if (nums[x] <= pivot){

	lea	r9, QWORD PTR b_new$[rsp]
	movsx	rax, dl
	add	r9, rax
	movzx	r10d, BYTE PTR [r9]
	cmp	r10b, r11b
	jg	SHORT $LN387@median_fil

; 15   : 			SWAP(i, x);

	movsx	rax, r8b
	movzx	ecx, BYTE PTR b_new$[rsp+rax]
	mov	BYTE PTR b_new$[rsp+rax], r10b
	movzx	eax, r8b

; 16   : 			i++;

	lea	r8d, DWORD PTR [rdx+1]
	movzx	edx, al
	mov	BYTE PTR [r9], cl
$LN387@median_fil:

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	inc	dl
	cmp	dl, 4
	jl	SHORT $LL388@median_fil

; 17   : 		}
; 18   : 	}
; 19   : 	SWAP(i, right);

	movsx	rax, r8b
	lea	rcx, QWORD PTR b_new$[rsp]
	mov	r9d, 3
	add	rcx, rax
	movzx	eax, BYTE PTR b_new$[rsp+4]
	xor	r8d, r8d
	movzx	edx, BYTE PTR [rcx]
	mov	BYTE PTR [rcx], al
	lea	rcx, QWORD PTR b_new$[rsp]
	mov	BYTE PTR b_new$[rsp+4], dl
	lea	rdx, QWORD PTR b_new_p$[rsp]
	call	?quicksort@@YAXPEADPEACHH@Z		; quicksort

; 20   : 	return i;
; 21   : }
; 22   : 
; 23   : 
; 24   : void quicksort(char *nums, signed char* pos, int left, int right){
; 25   : 	//char new_p[5] = {21, 22, 23, 24, 25};
; 26   : 	signed char p;	//p is position of pivot in the partitioned array
; 27   : 	
; 28   : 	if (left < right){
; 29   : 		p = partition(nums, pos, left, right);
; 30   : 		quicksort(nums, pos, left, p - 1);
; 31   : 		quicksort(nums, pos, p + 1, right);
; 32   : 	}
; 33   : 	return;
; 34   : }
; 35   : /*
; 36   : int quickselect(char *nums, char* pos, int left, int right, int k){
; 37   : 	int p = partition(nums, new_p, left, right);	//p is position of pivot in the partitioned array
; 38   : 	int r;
; 39   : 	
; 40   : 	//k equals pivot got lucky
; 41   : 	if (p == k-1){
; 42   : 		r = nums[p];
; 43   : 	}
; 44   : 	//k less than pivot
; 45   : 	else if (k - 1 < p){
; 46   : 		r = quickselect(nums, new_p, left, p - 1, k);
; 47   : 	}
; 48   : 	//k greater than pivot
; 49   : 	else{
; 50   : 		r = quickselect(nums, new_p, p + 1, right, k);
; 51   : 	}
; 52   : 	pos = new_p;
; 53   : 	return r;
; 54   : }
; 55   : */
; 56   : 
; 57   : 
; 58   : void sort_and_merge(char* a, char* b, char* c, signed char* a_pos, signed char* b_pos, signed char* c_pos){
; 59   : 	int i, j, k;
; 60   : 	quicksort(c, c_pos, 0, FILTER_W-1);
; 61   : 	for(i = 0,j = 0, k = 0; i < FILTER_W * FILTER_H; i++){

	mov	rcx, rbx

; 68   : 			b[i] = c[j];

	mov	rdx, rbx
$LL379@median_fil:

; 62   : 		while(a_pos[i] < 1) k++;

	cmp	BYTE PTR b_b_p$[rbp+rcx-256], 1
	jl	$LL376@median_fil

; 63   : 		if(a[i+k] <= c[j]) {

	movzx	eax, BYTE PTR b_new$[rsp+rdx]
	lea	r8, QWORD PTR [rbx+rcx]
	movzx	r9d, BYTE PTR b_b$[rbp+r8-256]
	cmp	r9b, al
	jg	SHORT $LN374@median_fil

; 64   : 			b[i] = a[i+k];
; 65   : 			b_pos[i] = a_pos[i+k];

	movzx	eax, BYTE PTR b_b_p$[rbp+r8-256]
	mov	BYTE PTR b_a$[rbp+rcx-256], r9b

; 66   : 		}
; 67   : 		else {

	jmp	SHORT $LN1381@median_fil
$LN374@median_fil:

; 68   : 			b[i] = c[j];

	mov	BYTE PTR b_a$[rbp+rcx-256], al

; 69   : 			b_pos[i] = c_pos[j];

	movzx	eax, BYTE PTR b_new_p$[rsp+rdx]
	inc	rdx
$LN1381@median_fil:
	mov	BYTE PTR b_a_p$[rsp+rcx], al
	inc	rcx
	cmp	rcx, 25
	jl	SHORT $LL379@median_fil

; 326  : 			}
; 327  : 			
; 328  : 			//Sorting new values and merging the 2 tables
; 329  : 			sort_and_merge(r_b, r_a, r_new, r_b_p, r_a_p, r_new_p);
; 330  : 			sort_and_merge(g_b, g_a, g_new, g_b_p, g_a_p, g_new_p);
; 331  : 			sort_and_merge(b_b, b_a, b_new, b_b_p, b_a_p, b_new_p);
; 332  : 			
; 333  : 			//Writing out calculated pixel
; 334  : 			imgDst[base_out] 		= r_a[12];

	mov	rdx, QWORD PTR imgDst$GSCopy$1$[rsp]
	movzx	r15d, BYTE PTR r_a$[rbp-244]

; 335  : 			imgDst[base_out + 1]	= g_a[12];

	movzx	r12d, BYTE PTR g_a$[rbp-244]

; 336  : 			imgDst[base_out + 2]	= b_a[12];

	movzx	r13d, BYTE PTR b_a$[rbp-244]
	add	r14d, 2
	mov	BYTE PTR [rdi+rdx+4], r15b
	mov	BYTE PTR [rdx+rdi+5], r12b
	mov	BYTE PTR [rdx+rdi+6], r13b

; 337  : 			
; 338  : 			//Updating base addresses
; 339  : 			base += 4;
; 340  : 			base_out += 4;

	add	rdi, 8
	add	rsi, 4
	cmp	r14d, DWORD PTR imgWidth$GSCopy$1$[rsp]
	jl	$LL63@median_fil
$LN1350@median_fil:
	mov	ecx, DWORD PTR Y$1$[rsp]
$LN825@median_fil:

; 341  : 		}
; 342  : 		
; 343  : 		//Edge is reached here
; 344  : 		Y++;	//Next row
; 345  : 		//Updating base addresses
; 346  : 		base = (Y * imgWidthF - FILTER_W + 1) * 4; //base += (imgWidth + 1) * 4;

	lea	eax, DWORD PTR [rcx+1]
	imul	eax, DWORD PTR imgWidthF$1$[rsp]

; 347  : 		base_out = ((Y + 1) * imgWidth) * 4;

	add	ecx, 2
	mov	edi, ecx
	mov	DWORD PTR Y$1$[rsp], ecx

; 348  : 		
; 349  : 		
; 350  : 		//Vertical movement, right side
; 351  : 
; 352  : 		//Getting new positions
; 353  : 		for(i = FILTER_H; i > 0; i--){

	mov	rcx, rbx
	lea	esi, DWORD PTR [rax*4-16]
	mov	eax, 5
	imul	edi, DWORD PTR imgWidth$GSCopy$1$[rsp]
	shl	edi, 2
	npad	9
$LL46@median_fil:

; 354  : 			r_new_p[i] = i;

	mov	BYTE PTR r_new_p$[rsp+rcx+5], al

; 355  : 			g_new_p[i] = i;

	mov	BYTE PTR g_new_p$[rsp+rcx+5], al

; 356  : 			b_new_p[i] = i;

	mov	BYTE PTR b_new_p$[rsp+rcx+5], al
	dec	eax
	lea	rcx, QWORD PTR [rcx-1]
	test	eax, eax
	jg	SHORT $LL46@median_fil

; 357  : 		}
; 358  : 		//VAGY LOOK-UP TABLE
; 359  : 		//Updating A positions
; 360  : 		for(i = 0; i < FILTER_H * FILTER_W; i++){

	mov	r10d, ebx
	npad	7
$LL43@median_fil:

; 361  : 			r_a_p[i] = r_a_p[i] + 19 - r_a_p[i] / (FILTER_H + 1) * 10;

	movsxd	r9, r10d
	mov	eax, 715827883				; 2aaaaaabH
	movsx	r8d, BYTE PTR r_a_p$[rbp+r9-256]
	imul	r8d
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	movzx	eax, dl
	shl	al, 2
	add	dl, al

; 362  : 			if(r_a_p[i] % FILTER_H == 0) r_a_p[i] = 0;

	mov	eax, 1717986919				; 66666667H
	add	dl, dl
	sub	r8b, dl
	add	r8b, 19
	movsx	ecx, r8b
	mov	BYTE PTR r_a_p$[rbp+r9-256], r8b
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	lea	eax, DWORD PTR [rdx+rdx*4]
	cmp	ecx, eax
	jne	SHORT $LN40@median_fil
	cmp	r9, 25
	jae	$LN1394@median_fil
	mov	BYTE PTR r_a_p$[rbp+r9-256], 0
$LN40@median_fil:

; 363  : 			
; 364  : 			g_a_p[i] = g_a_p[i] + 19 - g_a_p[i] / (FILTER_H + 1) * 10;

	movsx	r8d, BYTE PTR g_a_p$[rbp+r9-256]
	mov	eax, 715827883				; 2aaaaaabH
	imul	r8d
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	movzx	eax, dl
	shl	al, 2
	add	dl, al

; 365  : 			if(g_a_p[i] % FILTER_H == 0) g_a_p[i] = 0;

	mov	eax, 1717986919				; 66666667H
	add	dl, dl
	sub	r8b, dl
	add	r8b, 19
	movsx	ecx, r8b
	mov	BYTE PTR g_a_p$[rbp+r9-256], r8b
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	lea	eax, DWORD PTR [rdx+rdx*4]
	cmp	ecx, eax
	jne	SHORT $LN39@median_fil
	cmp	r9, 25
	jae	$LN82@median_fil
	mov	BYTE PTR g_a_p$[rbp+r9-256], 0
$LN39@median_fil:

; 366  : 			
; 367  : 			b_a_p[i] = b_a_p[i] + 19 - b_a_p[i] / (FILTER_H + 1) * 10;

	movsx	r8d, BYTE PTR b_a_p$[rsp+r9]
	mov	eax, 715827883				; 2aaaaaabH
	imul	r8d
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	movzx	eax, dl
	shl	al, 2
	add	dl, al

; 368  : 			if(b_a_p[i] % FILTER_H == 0) b_a_p[i] = 0;

	mov	eax, 1717986919				; 66666667H
	add	dl, dl
	sub	r8b, dl
	add	r8b, 19
	movsx	ecx, r8b
	mov	BYTE PTR b_a_p$[rsp+r9], r8b
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	lea	eax, DWORD PTR [rdx+rdx*4]
	cmp	ecx, eax
	jne	SHORT $LN42@median_fil
	cmp	r9, 25
	jae	$LN84@median_fil
	mov	BYTE PTR b_a_p$[rsp+r9], 0
$LN42@median_fil:

; 357  : 		}
; 358  : 		//VAGY LOOK-UP TABLE
; 359  : 		//Updating A positions
; 360  : 		for(i = 0; i < FILTER_H * FILTER_W; i++){

	inc	r10d
	cmp	r10d, 25
	jl	$LL43@median_fil

; 369  : 		}
; 370  : 		
; 371  : 		//Reading new values from the original image
; 372  : 		for(i = 0; i < FILTER_W; i++){

	mov	rcx, QWORD PTR imgSrc$[rbp-256]
	movsxd	rax, esi

; 373  : 			r_new[i] = imgSrc[base + i * 4];

	mov	rdx, rbx
	add	rcx, 2
	mov	r8d, 5
	add	rcx, rax
	npad	4
$LL37@median_fil:
	movzx	eax, BYTE PTR [rcx-2]
	inc	rdx
	lea	rcx, QWORD PTR [rcx+4]
	mov	BYTE PTR r_new$[rsp+rdx-1], al

; 374  : 			g_new[i] = imgSrc[base + i * 4 + 1];

	movzx	eax, BYTE PTR [rcx-5]
	mov	BYTE PTR g_new$[rsp+rdx-1], al

; 375  : 			b_new[i] = imgSrc[base + i * 4 + 2];

	movzx	eax, BYTE PTR [rcx-4]
	mov	BYTE PTR b_new$[rsp+rdx-1], al
	dec	r8
	jne	SHORT $LL37@median_fil

; 9    : 	char pivot = nums[right], i, x;

	movzx	r11d, BYTE PTR r_new$[rsp+4]

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	xor	dl, dl
	npad	4
$LL416@median_fil:

; 14   : 		if (nums[x] <= pivot){

	lea	r9, QWORD PTR r_new$[rsp]
	movsx	rax, dl
	add	r9, rax
	movzx	r10d, BYTE PTR [r9]
	cmp	r10b, r11b
	jg	SHORT $LN415@median_fil

; 15   : 			SWAP(i, x);

	movsx	rax, r8b
	movzx	ecx, BYTE PTR r_new$[rsp+rax]
	mov	BYTE PTR r_new$[rsp+rax], r10b
	movzx	eax, r8b

; 16   : 			i++;

	lea	r8d, DWORD PTR [rdx+1]
	movzx	edx, al
	mov	BYTE PTR [r9], cl
$LN415@median_fil:

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	inc	dl
	cmp	dl, 4
	jl	SHORT $LL416@median_fil

; 17   : 		}
; 18   : 	}
; 19   : 	SWAP(i, right);

	movsx	rax, r8b
	lea	rcx, QWORD PTR r_new$[rsp]
	mov	r9d, 3
	add	rcx, rax
	movzx	eax, BYTE PTR r_new$[rsp+4]
	xor	r8d, r8d
	movzx	edx, BYTE PTR [rcx]
	mov	BYTE PTR [rcx], al
	lea	rcx, QWORD PTR r_new$[rsp]
	mov	BYTE PTR r_new$[rsp+4], dl
	lea	rdx, QWORD PTR r_new_p$[rsp]
	call	?quicksort@@YAXPEADPEACHH@Z		; quicksort

; 20   : 	return i;
; 21   : }
; 22   : 
; 23   : 
; 24   : void quicksort(char *nums, signed char* pos, int left, int right){
; 25   : 	//char new_p[5] = {21, 22, 23, 24, 25};
; 26   : 	signed char p;	//p is position of pivot in the partitioned array
; 27   : 	
; 28   : 	if (left < right){
; 29   : 		p = partition(nums, pos, left, right);
; 30   : 		quicksort(nums, pos, left, p - 1);
; 31   : 		quicksort(nums, pos, p + 1, right);
; 32   : 	}
; 33   : 	return;
; 34   : }
; 35   : /*
; 36   : int quickselect(char *nums, char* pos, int left, int right, int k){
; 37   : 	int p = partition(nums, new_p, left, right);	//p is position of pivot in the partitioned array
; 38   : 	int r;
; 39   : 	
; 40   : 	//k equals pivot got lucky
; 41   : 	if (p == k-1){
; 42   : 		r = nums[p];
; 43   : 	}
; 44   : 	//k less than pivot
; 45   : 	else if (k - 1 < p){
; 46   : 		r = quickselect(nums, new_p, left, p - 1, k);
; 47   : 	}
; 48   : 	//k greater than pivot
; 49   : 	else{
; 50   : 		r = quickselect(nums, new_p, p + 1, right, k);
; 51   : 	}
; 52   : 	pos = new_p;
; 53   : 	return r;
; 54   : }
; 55   : */
; 56   : 
; 57   : 
; 58   : void sort_and_merge(char* a, char* b, char* c, signed char* a_pos, signed char* b_pos, signed char* c_pos){
; 59   : 	int i, j, k;
; 60   : 	quicksort(c, c_pos, 0, FILTER_W-1);
; 61   : 	for(i = 0,j = 0, k = 0; i < FILTER_W * FILTER_H; i++){

	mov	rcx, rbx

; 68   : 			b[i] = c[j];

	mov	rdx, rbx
$LL407@median_fil:

; 62   : 		while(a_pos[i] < 1) k++;

	cmp	BYTE PTR r_a_p$[rbp+rcx-256], 1
	jl	$LL404@median_fil

; 63   : 		if(a[i+k] <= c[j]) {

	movzx	eax, BYTE PTR r_new$[rsp+rdx]
	lea	r8, QWORD PTR [rbx+rcx]
	movzx	r9d, BYTE PTR r_a$[rbp+r8-256]
	cmp	r9b, al
	jg	SHORT $LN402@median_fil

; 64   : 			b[i] = a[i+k];
; 65   : 			b_pos[i] = a_pos[i+k];

	movzx	eax, BYTE PTR r_a_p$[rbp+r8-256]
	mov	BYTE PTR r_b$[rbp+rcx-256], r9b

; 66   : 		}
; 67   : 		else {

	jmp	SHORT $LN1382@median_fil
$LN402@median_fil:

; 68   : 			b[i] = c[j];

	mov	BYTE PTR r_b$[rbp+rcx-256], al

; 69   : 			b_pos[i] = c_pos[j];

	movzx	eax, BYTE PTR r_new_p$[rsp+rdx]
	inc	rdx
$LN1382@median_fil:
	mov	BYTE PTR r_b_p$[rbp+rcx-256], al
	inc	rcx
	cmp	rcx, 25
	jl	SHORT $LL407@median_fil

; 9    : 	char pivot = nums[right], i, x;

	movzx	r11d, BYTE PTR g_new$[rsp+4]

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	xor	dl, dl
	xor	r8b, r8b
$LL444@median_fil:

; 14   : 		if (nums[x] <= pivot){

	lea	r9, QWORD PTR g_new$[rsp]
	movsx	rax, dl
	add	r9, rax
	movzx	r10d, BYTE PTR [r9]
	cmp	r10b, r11b
	jg	SHORT $LN443@median_fil

; 15   : 			SWAP(i, x);

	movsx	rax, r8b
	movzx	ecx, BYTE PTR g_new$[rsp+rax]
	mov	BYTE PTR g_new$[rsp+rax], r10b
	movzx	eax, r8b

; 16   : 			i++;

	lea	r8d, DWORD PTR [rdx+1]
	movzx	edx, al
	mov	BYTE PTR [r9], cl
$LN443@median_fil:

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	inc	dl
	cmp	dl, 4
	jl	SHORT $LL444@median_fil

; 17   : 		}
; 18   : 	}
; 19   : 	SWAP(i, right);

	movsx	rax, r8b
	lea	rcx, QWORD PTR g_new$[rsp]
	mov	r9d, 3
	add	rcx, rax
	movzx	eax, BYTE PTR g_new$[rsp+4]
	xor	r8d, r8d
	movzx	edx, BYTE PTR [rcx]
	mov	BYTE PTR [rcx], al
	lea	rcx, QWORD PTR g_new$[rsp]
	mov	BYTE PTR g_new$[rsp+4], dl
	lea	rdx, QWORD PTR g_new_p$[rsp]
	call	?quicksort@@YAXPEADPEACHH@Z		; quicksort

; 20   : 	return i;
; 21   : }
; 22   : 
; 23   : 
; 24   : void quicksort(char *nums, signed char* pos, int left, int right){
; 25   : 	//char new_p[5] = {21, 22, 23, 24, 25};
; 26   : 	signed char p;	//p is position of pivot in the partitioned array
; 27   : 	
; 28   : 	if (left < right){
; 29   : 		p = partition(nums, pos, left, right);
; 30   : 		quicksort(nums, pos, left, p - 1);
; 31   : 		quicksort(nums, pos, p + 1, right);
; 32   : 	}
; 33   : 	return;
; 34   : }
; 35   : /*
; 36   : int quickselect(char *nums, char* pos, int left, int right, int k){
; 37   : 	int p = partition(nums, new_p, left, right);	//p is position of pivot in the partitioned array
; 38   : 	int r;
; 39   : 	
; 40   : 	//k equals pivot got lucky
; 41   : 	if (p == k-1){
; 42   : 		r = nums[p];
; 43   : 	}
; 44   : 	//k less than pivot
; 45   : 	else if (k - 1 < p){
; 46   : 		r = quickselect(nums, new_p, left, p - 1, k);
; 47   : 	}
; 48   : 	//k greater than pivot
; 49   : 	else{
; 50   : 		r = quickselect(nums, new_p, p + 1, right, k);
; 51   : 	}
; 52   : 	pos = new_p;
; 53   : 	return r;
; 54   : }
; 55   : */
; 56   : 
; 57   : 
; 58   : void sort_and_merge(char* a, char* b, char* c, signed char* a_pos, signed char* b_pos, signed char* c_pos){
; 59   : 	int i, j, k;
; 60   : 	quicksort(c, c_pos, 0, FILTER_W-1);
; 61   : 	for(i = 0,j = 0, k = 0; i < FILTER_W * FILTER_H; i++){

	mov	rcx, rbx

; 68   : 			b[i] = c[j];

	mov	rdx, rbx
$LL435@median_fil:

; 62   : 		while(a_pos[i] < 1) k++;

	cmp	BYTE PTR g_a_p$[rbp+rcx-256], 1
	jl	$LL432@median_fil

; 63   : 		if(a[i+k] <= c[j]) {

	movzx	eax, BYTE PTR g_new$[rsp+rdx]
	lea	r8, QWORD PTR [rbx+rcx]
	movzx	r9d, BYTE PTR g_a$[rbp+r8-256]
	cmp	r9b, al
	jg	SHORT $LN430@median_fil

; 64   : 			b[i] = a[i+k];
; 65   : 			b_pos[i] = a_pos[i+k];

	movzx	eax, BYTE PTR g_a_p$[rbp+r8-256]
	mov	BYTE PTR g_b$[rbp+rcx-256], r9b

; 66   : 		}
; 67   : 		else {

	jmp	SHORT $LN1383@median_fil
$LN430@median_fil:

; 68   : 			b[i] = c[j];

	mov	BYTE PTR g_b$[rbp+rcx-256], al

; 69   : 			b_pos[i] = c_pos[j];

	movzx	eax, BYTE PTR g_new_p$[rsp+rdx]
	inc	rdx
$LN1383@median_fil:
	mov	BYTE PTR g_b_p$[rbp+rcx-256], al
	inc	rcx
	cmp	rcx, 25
	jl	SHORT $LL435@median_fil

; 9    : 	char pivot = nums[right], i, x;

	movzx	r11d, BYTE PTR b_new$[rsp+4]

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	xor	dl, dl
	xor	r8b, r8b
	npad	7
$LL472@median_fil:

; 14   : 		if (nums[x] <= pivot){

	lea	r9, QWORD PTR b_new$[rsp]
	movsx	rax, dl
	add	r9, rax
	movzx	r10d, BYTE PTR [r9]
	cmp	r10b, r11b
	jg	SHORT $LN471@median_fil

; 15   : 			SWAP(i, x);

	movsx	rax, r8b
	movzx	ecx, BYTE PTR b_new$[rsp+rax]
	mov	BYTE PTR b_new$[rsp+rax], r10b
	movzx	eax, r8b

; 16   : 			i++;

	lea	r8d, DWORD PTR [rdx+1]
	movzx	edx, al
	mov	BYTE PTR [r9], cl
$LN471@median_fil:

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	inc	dl
	cmp	dl, 4
	jl	SHORT $LL472@median_fil

; 17   : 		}
; 18   : 	}
; 19   : 	SWAP(i, right);

	movsx	rax, r8b
	lea	rcx, QWORD PTR b_new$[rsp]
	mov	r9d, 3
	add	rcx, rax
	movzx	eax, BYTE PTR b_new$[rsp+4]
	xor	r8d, r8d
	movzx	edx, BYTE PTR [rcx]
	mov	BYTE PTR [rcx], al
	lea	rcx, QWORD PTR b_new$[rsp]
	mov	BYTE PTR b_new$[rsp+4], dl
	lea	rdx, QWORD PTR b_new_p$[rsp]
	call	?quicksort@@YAXPEADPEACHH@Z		; quicksort

; 20   : 	return i;
; 21   : }
; 22   : 
; 23   : 
; 24   : void quicksort(char *nums, signed char* pos, int left, int right){
; 25   : 	//char new_p[5] = {21, 22, 23, 24, 25};
; 26   : 	signed char p;	//p is position of pivot in the partitioned array
; 27   : 	
; 28   : 	if (left < right){
; 29   : 		p = partition(nums, pos, left, right);
; 30   : 		quicksort(nums, pos, left, p - 1);
; 31   : 		quicksort(nums, pos, p + 1, right);
; 32   : 	}
; 33   : 	return;
; 34   : }
; 35   : /*
; 36   : int quickselect(char *nums, char* pos, int left, int right, int k){
; 37   : 	int p = partition(nums, new_p, left, right);	//p is position of pivot in the partitioned array
; 38   : 	int r;
; 39   : 	
; 40   : 	//k equals pivot got lucky
; 41   : 	if (p == k-1){
; 42   : 		r = nums[p];
; 43   : 	}
; 44   : 	//k less than pivot
; 45   : 	else if (k - 1 < p){
; 46   : 		r = quickselect(nums, new_p, left, p - 1, k);
; 47   : 	}
; 48   : 	//k greater than pivot
; 49   : 	else{
; 50   : 		r = quickselect(nums, new_p, p + 1, right, k);
; 51   : 	}
; 52   : 	pos = new_p;
; 53   : 	return r;
; 54   : }
; 55   : */
; 56   : 
; 57   : 
; 58   : void sort_and_merge(char* a, char* b, char* c, signed char* a_pos, signed char* b_pos, signed char* c_pos){
; 59   : 	int i, j, k;
; 60   : 	quicksort(c, c_pos, 0, FILTER_W-1);
; 61   : 	for(i = 0,j = 0, k = 0; i < FILTER_W * FILTER_H; i++){

	mov	rcx, rbx

; 68   : 			b[i] = c[j];

	mov	rdx, rbx
$LL463@median_fil:

; 62   : 		while(a_pos[i] < 1) k++;

	cmp	BYTE PTR b_a_p$[rsp+rcx], 1
	jl	$LL460@median_fil

; 63   : 		if(a[i+k] <= c[j]) {

	movzx	eax, BYTE PTR b_new$[rsp+rdx]
	lea	r8, QWORD PTR [rbx+rcx]
	movzx	r9d, BYTE PTR b_a$[rbp+r8-256]
	cmp	r9b, al
	jg	SHORT $LN458@median_fil

; 64   : 			b[i] = a[i+k];
; 65   : 			b_pos[i] = a_pos[i+k];

	movzx	eax, BYTE PTR b_a_p$[rsp+r8]
	mov	BYTE PTR b_b$[rbp+rcx-256], r9b

; 66   : 		}
; 67   : 		else {

	jmp	SHORT $LN1384@median_fil
$LN458@median_fil:

; 68   : 			b[i] = c[j];

	mov	BYTE PTR b_b$[rbp+rcx-256], al

; 69   : 			b_pos[i] = c_pos[j];

	movzx	eax, BYTE PTR b_new_p$[rsp+rdx]
	inc	rdx
$LN1384@median_fil:
	mov	BYTE PTR b_b_p$[rbp+rcx-256], al
	inc	rcx
	cmp	rcx, 25
	jl	SHORT $LL463@median_fil

; 376  : 		}
; 377  : 		
; 378  : 		//Sorting new values and merging the 2 tables
; 379  : 		sort_and_merge(r_a, r_b, r_new, r_a_p, r_b_p, r_new_p);
; 380  : 		sort_and_merge(g_a, g_b, g_new, g_a_p, g_b_p, g_new_p);
; 381  : 		sort_and_merge(b_a, b_b, b_new, b_a_p, b_b_p, b_new_p);
; 382  : 		
; 383  : 		//Writing out calculated pixel
; 384  : 		imgDst[base_out] 		= r_a[12];

	mov	rcx, QWORD PTR imgDst$GSCopy$1$[rsp]
	movsxd	rax, edi
	mov	BYTE PTR [rax+rcx], r15b

; 385  : 		imgDst[base_out + 1]	= g_a[12];

	mov	BYTE PTR [rax+rcx+1], r12b

; 386  : 		imgDst[base_out + 2]	= b_a[12];

	mov	BYTE PTR [rax+rcx+2], r13b

; 387  : 		
; 388  : 		//Updating base addresses
; 389  : 		base -= 4;

	lea	eax, DWORD PTR [rsi-4]

; 391  : 		
; 392  : 		
; 393  : 		//Horizontal part, backward
; 394  : 		for(X = imgWidth; X > 0; X -= 2){

	mov	esi, DWORD PTR imgWidth$GSCopy$1$[rsp]
	lea	ecx, DWORD PTR [rdi-4]
	mov	r14d, esi
	test	esi, esi
	jle	$LN826@median_fil

; 390  : 		base_out -= 4;

	movsxd	rsi, eax
	movsxd	rdi, ecx
	npad	7
$LL34@median_fil:

; 395  : 			
; 396  : 			//Updating A positions
; 397  : 			for(i = 0; i < FILTER_H * FILTER_W; i++){

	mov	rax, rbx
	mov	ecx, 25
	npad	8
$LL31@median_fil:

; 398  : 				r_a_p[i] = r_a_p[i] - 5;

	add	BYTE PTR r_a_p$[rbp+rax-256], -5

; 399  : 				g_a_p[i] = g_a_p[i] - 5;

	add	BYTE PTR g_a_p$[rbp+rax-256], -5

; 400  : 				b_a_p[i] = b_a_p[i] - 5;

	add	BYTE PTR b_a_p$[rsp+rax], -5
	lea	rax, QWORD PTR [rax+1]
	dec	rcx
	jne	SHORT $LL31@median_fil

; 401  : 			}
; 402  : 			
; 403  : 			//Reading new values from the original image and getting new positions
; 404  : 			for(i = 0; i < FILTER_W; i++){

	mov	rdx, QWORD PTR imgSrc$[rbp-256]
	mov	r15, QWORD PTR tv12264[rsp]
	mov	r8d, ebx
	add	rdx, 2

; 408  : 
; 409  : 				r_new[i] = imgSrc[base + i * imgWidthF * 4];

	mov	rcx, rbx
	add	rdx, rsi
$LL28@median_fil:

; 401  : 			}
; 402  : 			
; 403  : 			//Reading new values from the original image and getting new positions
; 404  : 			for(i = 0; i < FILTER_W; i++){

	lea	eax, DWORD PTR [r8+20]
	inc	r8d
	lea	rcx, QWORD PTR [rcx+1]

; 405  : 				r_new_p[i] = FILTER_H * (FILTER_W - 1) + i;

	mov	BYTE PTR r_new_p$[rsp+rcx-1], al

; 406  : 				g_new_p[i] = FILTER_H * (FILTER_W - 1) + i;

	mov	BYTE PTR g_new_p$[rsp+rcx-1], al

; 407  : 				b_new_p[i] = FILTER_H * (FILTER_W - 1) + i;

	mov	BYTE PTR b_new_p$[rsp+rcx-1], al

; 408  : 
; 409  : 				r_new[i] = imgSrc[base + i * imgWidthF * 4];

	movzx	eax, BYTE PTR [rdx-2]
	mov	BYTE PTR r_new$[rsp+rcx-1], al

; 410  : 				g_new[i] = imgSrc[base + i * imgWidthF * 4 + 1];

	movzx	eax, BYTE PTR [rdx-1]
	mov	BYTE PTR g_new$[rsp+rcx-1], al

; 411  : 				b_new[i] = imgSrc[base + i * imgWidthF * 4 + 2];

	movzx	eax, BYTE PTR [rdx]
	add	rdx, r15
	mov	BYTE PTR b_new$[rsp+rcx-1], al
	cmp	r8d, 5
	jl	SHORT $LL28@median_fil
	movzx	r15d, BYTE PTR r_a$[rbp-244]

; 9    : 	char pivot = nums[right], i, x;

	movzx	r11d, BYTE PTR r_new$[rsp+4]

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	xor	dl, dl
	xor	r8b, r8b
	npad	8
$LL500@median_fil:

; 14   : 		if (nums[x] <= pivot){

	lea	r9, QWORD PTR r_new$[rsp]
	movsx	rax, dl
	add	r9, rax
	movzx	r10d, BYTE PTR [r9]
	cmp	r10b, r11b
	jg	SHORT $LN499@median_fil

; 15   : 			SWAP(i, x);

	movsx	rax, r8b
	movzx	ecx, BYTE PTR r_new$[rsp+rax]
	mov	BYTE PTR r_new$[rsp+rax], r10b
	movzx	eax, r8b

; 16   : 			i++;

	lea	r8d, DWORD PTR [rdx+1]
	movzx	edx, al
	mov	BYTE PTR [r9], cl
$LN499@median_fil:

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	inc	dl
	cmp	dl, 4
	jl	SHORT $LL500@median_fil

; 17   : 		}
; 18   : 	}
; 19   : 	SWAP(i, right);

	movsx	rax, r8b
	lea	rcx, QWORD PTR r_new$[rsp]
	mov	r9d, 3
	add	rcx, rax
	movzx	eax, BYTE PTR r_new$[rsp+4]
	xor	r8d, r8d
	movzx	edx, BYTE PTR [rcx]
	mov	BYTE PTR [rcx], al
	lea	rcx, QWORD PTR r_new$[rsp]
	mov	BYTE PTR r_new$[rsp+4], dl
	lea	rdx, QWORD PTR r_new_p$[rsp]
	call	?quicksort@@YAXPEADPEACHH@Z		; quicksort

; 20   : 	return i;
; 21   : }
; 22   : 
; 23   : 
; 24   : void quicksort(char *nums, signed char* pos, int left, int right){
; 25   : 	//char new_p[5] = {21, 22, 23, 24, 25};
; 26   : 	signed char p;	//p is position of pivot in the partitioned array
; 27   : 	
; 28   : 	if (left < right){
; 29   : 		p = partition(nums, pos, left, right);
; 30   : 		quicksort(nums, pos, left, p - 1);
; 31   : 		quicksort(nums, pos, p + 1, right);
; 32   : 	}
; 33   : 	return;
; 34   : }
; 35   : /*
; 36   : int quickselect(char *nums, char* pos, int left, int right, int k){
; 37   : 	int p = partition(nums, new_p, left, right);	//p is position of pivot in the partitioned array
; 38   : 	int r;
; 39   : 	
; 40   : 	//k equals pivot got lucky
; 41   : 	if (p == k-1){
; 42   : 		r = nums[p];
; 43   : 	}
; 44   : 	//k less than pivot
; 45   : 	else if (k - 1 < p){
; 46   : 		r = quickselect(nums, new_p, left, p - 1, k);
; 47   : 	}
; 48   : 	//k greater than pivot
; 49   : 	else{
; 50   : 		r = quickselect(nums, new_p, p + 1, right, k);
; 51   : 	}
; 52   : 	pos = new_p;
; 53   : 	return r;
; 54   : }
; 55   : */
; 56   : 
; 57   : 
; 58   : void sort_and_merge(char* a, char* b, char* c, signed char* a_pos, signed char* b_pos, signed char* c_pos){
; 59   : 	int i, j, k;
; 60   : 	quicksort(c, c_pos, 0, FILTER_W-1);
; 61   : 	for(i = 0,j = 0, k = 0; i < FILTER_W * FILTER_H; i++){

	mov	rcx, rbx

; 68   : 			b[i] = c[j];

	mov	rdx, rbx
$LL491@median_fil:

; 62   : 		while(a_pos[i] < 1) k++;

	cmp	BYTE PTR r_a_p$[rbp+rcx-256], 1
	jl	$LL488@median_fil

; 63   : 		if(a[i+k] <= c[j]) {

	movzx	eax, BYTE PTR r_new$[rsp+rdx]
	lea	r8, QWORD PTR [rbx+rcx]
	movzx	r9d, BYTE PTR r_a$[rbp+r8-256]
	cmp	r9b, al
	jg	SHORT $LN486@median_fil

; 64   : 			b[i] = a[i+k];
; 65   : 			b_pos[i] = a_pos[i+k];

	movzx	eax, BYTE PTR r_a_p$[rbp+r8-256]
	mov	BYTE PTR r_b$[rbp+rcx-256], r9b

; 66   : 		}
; 67   : 		else {

	jmp	SHORT $LN1385@median_fil
$LN486@median_fil:

; 68   : 			b[i] = c[j];

	mov	BYTE PTR r_b$[rbp+rcx-256], al

; 69   : 			b_pos[i] = c_pos[j];

	movzx	eax, BYTE PTR r_new_p$[rsp+rdx]
	inc	rdx
$LN1385@median_fil:
	mov	BYTE PTR r_b_p$[rbp+rcx-256], al
	inc	rcx
	cmp	rcx, 25
	jl	SHORT $LL491@median_fil

; 9    : 	char pivot = nums[right], i, x;

	movzx	r11d, BYTE PTR g_new$[rsp+4]

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	xor	dl, dl
	xor	r8b, r8b
$LL528@median_fil:

; 14   : 		if (nums[x] <= pivot){

	lea	r9, QWORD PTR g_new$[rsp]
	movsx	rax, dl
	add	r9, rax
	movzx	r10d, BYTE PTR [r9]
	cmp	r10b, r11b
	jg	SHORT $LN527@median_fil

; 15   : 			SWAP(i, x);

	movsx	rax, r8b
	movzx	ecx, BYTE PTR g_new$[rsp+rax]
	mov	BYTE PTR g_new$[rsp+rax], r10b
	movzx	eax, r8b

; 16   : 			i++;

	lea	r8d, DWORD PTR [rdx+1]
	movzx	edx, al
	mov	BYTE PTR [r9], cl
$LN527@median_fil:

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	inc	dl
	cmp	dl, 4
	jl	SHORT $LL528@median_fil

; 17   : 		}
; 18   : 	}
; 19   : 	SWAP(i, right);

	movsx	rax, r8b
	lea	rcx, QWORD PTR g_new$[rsp]
	mov	r9d, 3
	add	rcx, rax
	movzx	eax, BYTE PTR g_new$[rsp+4]
	xor	r8d, r8d
	movzx	edx, BYTE PTR [rcx]
	mov	BYTE PTR [rcx], al
	lea	rcx, QWORD PTR g_new$[rsp]
	mov	BYTE PTR g_new$[rsp+4], dl
	lea	rdx, QWORD PTR g_new_p$[rsp]
	call	?quicksort@@YAXPEADPEACHH@Z		; quicksort

; 20   : 	return i;
; 21   : }
; 22   : 
; 23   : 
; 24   : void quicksort(char *nums, signed char* pos, int left, int right){
; 25   : 	//char new_p[5] = {21, 22, 23, 24, 25};
; 26   : 	signed char p;	//p is position of pivot in the partitioned array
; 27   : 	
; 28   : 	if (left < right){
; 29   : 		p = partition(nums, pos, left, right);
; 30   : 		quicksort(nums, pos, left, p - 1);
; 31   : 		quicksort(nums, pos, p + 1, right);
; 32   : 	}
; 33   : 	return;
; 34   : }
; 35   : /*
; 36   : int quickselect(char *nums, char* pos, int left, int right, int k){
; 37   : 	int p = partition(nums, new_p, left, right);	//p is position of pivot in the partitioned array
; 38   : 	int r;
; 39   : 	
; 40   : 	//k equals pivot got lucky
; 41   : 	if (p == k-1){
; 42   : 		r = nums[p];
; 43   : 	}
; 44   : 	//k less than pivot
; 45   : 	else if (k - 1 < p){
; 46   : 		r = quickselect(nums, new_p, left, p - 1, k);
; 47   : 	}
; 48   : 	//k greater than pivot
; 49   : 	else{
; 50   : 		r = quickselect(nums, new_p, p + 1, right, k);
; 51   : 	}
; 52   : 	pos = new_p;
; 53   : 	return r;
; 54   : }
; 55   : */
; 56   : 
; 57   : 
; 58   : void sort_and_merge(char* a, char* b, char* c, signed char* a_pos, signed char* b_pos, signed char* c_pos){
; 59   : 	int i, j, k;
; 60   : 	quicksort(c, c_pos, 0, FILTER_W-1);
; 61   : 	for(i = 0,j = 0, k = 0; i < FILTER_W * FILTER_H; i++){

	mov	rcx, rbx

; 68   : 			b[i] = c[j];

	mov	rdx, rbx
$LL519@median_fil:

; 62   : 		while(a_pos[i] < 1) k++;

	cmp	BYTE PTR g_a_p$[rbp+rcx-256], 1
	jl	$LL516@median_fil

; 63   : 		if(a[i+k] <= c[j]) {

	movzx	eax, BYTE PTR g_new$[rsp+rdx]
	lea	r8, QWORD PTR [rbx+rcx]
	movzx	r9d, BYTE PTR g_a$[rbp+r8-256]
	cmp	r9b, al
	jg	SHORT $LN514@median_fil

; 64   : 			b[i] = a[i+k];
; 65   : 			b_pos[i] = a_pos[i+k];

	movzx	eax, BYTE PTR g_a_p$[rbp+r8-256]
	mov	BYTE PTR g_b$[rbp+rcx-256], r9b

; 66   : 		}
; 67   : 		else {

	jmp	SHORT $LN1386@median_fil
$LN514@median_fil:

; 68   : 			b[i] = c[j];

	mov	BYTE PTR g_b$[rbp+rcx-256], al

; 69   : 			b_pos[i] = c_pos[j];

	movzx	eax, BYTE PTR g_new_p$[rsp+rdx]
	inc	rdx
$LN1386@median_fil:
	mov	BYTE PTR g_b_p$[rbp+rcx-256], al
	inc	rcx
	cmp	rcx, 25
	jl	SHORT $LL519@median_fil

; 9    : 	char pivot = nums[right], i, x;

	movzx	r11d, BYTE PTR b_new$[rsp+4]

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	xor	dl, dl
	xor	r8b, r8b
	npad	7
$LL556@median_fil:

; 14   : 		if (nums[x] <= pivot){

	lea	r9, QWORD PTR b_new$[rsp]
	movsx	rax, dl
	add	r9, rax
	movzx	r10d, BYTE PTR [r9]
	cmp	r10b, r11b
	jg	SHORT $LN555@median_fil

; 15   : 			SWAP(i, x);

	movsx	rax, r8b
	movzx	ecx, BYTE PTR b_new$[rsp+rax]
	mov	BYTE PTR b_new$[rsp+rax], r10b
	movzx	eax, r8b

; 16   : 			i++;

	lea	r8d, DWORD PTR [rdx+1]
	movzx	edx, al
	mov	BYTE PTR [r9], cl
$LN555@median_fil:

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	inc	dl
	cmp	dl, 4
	jl	SHORT $LL556@median_fil

; 17   : 		}
; 18   : 	}
; 19   : 	SWAP(i, right);

	movsx	rax, r8b
	lea	rcx, QWORD PTR b_new$[rsp]
	mov	r9d, 3
	add	rcx, rax
	movzx	eax, BYTE PTR b_new$[rsp+4]
	xor	r8d, r8d
	movzx	edx, BYTE PTR [rcx]
	mov	BYTE PTR [rcx], al
	lea	rcx, QWORD PTR b_new$[rsp]
	mov	BYTE PTR b_new$[rsp+4], dl
	lea	rdx, QWORD PTR b_new_p$[rsp]
	call	?quicksort@@YAXPEADPEACHH@Z		; quicksort

; 20   : 	return i;
; 21   : }
; 22   : 
; 23   : 
; 24   : void quicksort(char *nums, signed char* pos, int left, int right){
; 25   : 	//char new_p[5] = {21, 22, 23, 24, 25};
; 26   : 	signed char p;	//p is position of pivot in the partitioned array
; 27   : 	
; 28   : 	if (left < right){
; 29   : 		p = partition(nums, pos, left, right);
; 30   : 		quicksort(nums, pos, left, p - 1);
; 31   : 		quicksort(nums, pos, p + 1, right);
; 32   : 	}
; 33   : 	return;
; 34   : }
; 35   : /*
; 36   : int quickselect(char *nums, char* pos, int left, int right, int k){
; 37   : 	int p = partition(nums, new_p, left, right);	//p is position of pivot in the partitioned array
; 38   : 	int r;
; 39   : 	
; 40   : 	//k equals pivot got lucky
; 41   : 	if (p == k-1){
; 42   : 		r = nums[p];
; 43   : 	}
; 44   : 	//k less than pivot
; 45   : 	else if (k - 1 < p){
; 46   : 		r = quickselect(nums, new_p, left, p - 1, k);
; 47   : 	}
; 48   : 	//k greater than pivot
; 49   : 	else{
; 50   : 		r = quickselect(nums, new_p, p + 1, right, k);
; 51   : 	}
; 52   : 	pos = new_p;
; 53   : 	return r;
; 54   : }
; 55   : */
; 56   : 
; 57   : 
; 58   : void sort_and_merge(char* a, char* b, char* c, signed char* a_pos, signed char* b_pos, signed char* c_pos){
; 59   : 	int i, j, k;
; 60   : 	quicksort(c, c_pos, 0, FILTER_W-1);
; 61   : 	for(i = 0,j = 0, k = 0; i < FILTER_W * FILTER_H; i++){

	mov	rcx, rbx

; 68   : 			b[i] = c[j];

	mov	rdx, rbx
$LL547@median_fil:

; 62   : 		while(a_pos[i] < 1) k++;

	cmp	BYTE PTR b_a_p$[rsp+rcx], 1
	jl	$LL544@median_fil

; 63   : 		if(a[i+k] <= c[j]) {

	movzx	eax, BYTE PTR b_new$[rsp+rdx]
	lea	r8, QWORD PTR [rbx+rcx]
	movzx	r9d, BYTE PTR b_a$[rbp+r8-256]
	cmp	r9b, al
	jg	SHORT $LN542@median_fil

; 64   : 			b[i] = a[i+k];
; 65   : 			b_pos[i] = a_pos[i+k];

	movzx	eax, BYTE PTR b_a_p$[rsp+r8]
	mov	BYTE PTR b_b$[rbp+rcx-256], r9b

; 66   : 		}
; 67   : 		else {

	jmp	SHORT $LN1387@median_fil
$LN542@median_fil:

; 68   : 			b[i] = c[j];

	mov	BYTE PTR b_b$[rbp+rcx-256], al

; 69   : 			b_pos[i] = c_pos[j];

	movzx	eax, BYTE PTR b_new_p$[rsp+rdx]
	inc	rdx
$LN1387@median_fil:
	mov	BYTE PTR b_b_p$[rbp+rcx-256], al
	inc	rcx
	cmp	rcx, 25
	jl	SHORT $LL547@median_fil

; 412  : 			}
; 413  : 			
; 414  : 			//Sorting and merging the 2 tables
; 415  : 			//First from A+C->B then B+C->A
; 416  : 			sort_and_merge(r_a, r_b, r_new, r_a_p, r_b_p, r_new_p);
; 417  : 			sort_and_merge(g_a, g_b, g_new, g_a_p, g_b_p, g_new_p);
; 418  : 			sort_and_merge(b_a, b_b, b_new, b_a_p, b_b_p, b_new_p);
; 419  : 			
; 420  : 			//Writing out calculated pixel
; 421  : 			imgDst[base_out] 		= r_b[12];

	mov	rdx, QWORD PTR imgDst$GSCopy$1$[rsp]
	movzx	eax, BYTE PTR r_b$[rbp-244]
	mov	BYTE PTR [rdi+rdx], al

; 422  : 			imgDst[base_out + 1]	= g_b[12];

	movzx	eax, BYTE PTR g_b$[rbp-244]
	mov	BYTE PTR [rdx+rdi+1], al

; 423  : 			imgDst[base_out + 2]	= b_b[12];

	movzx	eax, BYTE PTR b_b$[rbp-244]
	mov	BYTE PTR [rdx+rdi+2], al

; 424  : 			
; 425  : 			if(X == 0) break;

	test	r14d, r14d
	je	$LN826@median_fil

; 426  : 			//Updating base addresses
; 427  : 			base -= 4;

	sub	rsi, 4

; 428  : 			base_out -= 4;
; 429  : 			
; 430  : 			
; 431  : 			//Updating B positions
; 432  : 			for(i = 0; i < FILTER_H; i++){

	mov	r8, rbx
	mov	r9d, 5
$LL24@median_fil:

; 433  : 				for(j = 0; j < FILTER_W; j++){

	add	BYTE PTR b_b_p$[rbp+r8-256], -25
	add	BYTE PTR r_b_p$[rbp+r8-256], -25
	add	BYTE PTR g_b_p$[rbp+r8-256], -25
	lea	r8, QWORD PTR [r8+1]
	dec	r9
	jne	SHORT $LL24@median_fil

; 434  : 					r_b_p[i] = r_b_p[i] - 5;
; 435  : 					g_b_p[i] = g_b_p[i] - 5;
; 436  : 					b_b_p[i] = b_b_p[i] - 5;
; 437  : 				}
; 438  : 			}
; 439  : 			
; 440  : 			//Reading new values from the original image and getting new positions
; 441  : 			for(i = 0; i < FILTER_W; i++){

	mov	rdx, QWORD PTR imgSrc$[rbp-256]
	mov	r8d, ebx

; 445  : 
; 446  : 				r_new[i] = imgSrc[base + i * imgWidthF * 4];

	mov	rcx, rbx
	mov	rbx, QWORD PTR tv12264[rsp]
	add	rdx, 2
	add	rdx, rsi
	npad	12
$LL18@median_fil:

; 434  : 					r_b_p[i] = r_b_p[i] - 5;
; 435  : 					g_b_p[i] = g_b_p[i] - 5;
; 436  : 					b_b_p[i] = b_b_p[i] - 5;
; 437  : 				}
; 438  : 			}
; 439  : 			
; 440  : 			//Reading new values from the original image and getting new positions
; 441  : 			for(i = 0; i < FILTER_W; i++){

	lea	eax, DWORD PTR [r8+20]
	inc	r8d
	lea	rcx, QWORD PTR [rcx+1]

; 442  : 				r_new_p[i] = FILTER_H * (FILTER_W - 1) + i;

	mov	BYTE PTR r_new_p$[rsp+rcx-1], al

; 443  : 				g_new_p[i] = FILTER_H * (FILTER_W - 1) + i;

	mov	BYTE PTR g_new_p$[rsp+rcx-1], al

; 444  : 				b_new_p[i] = FILTER_H * (FILTER_W - 1) + i;

	mov	BYTE PTR b_new_p$[rsp+rcx-1], al

; 445  : 
; 446  : 				r_new[i] = imgSrc[base + i * imgWidthF * 4];

	movzx	eax, BYTE PTR [rdx-2]
	mov	BYTE PTR r_new$[rsp+rcx-1], al

; 447  : 				g_new[i] = imgSrc[base + i * imgWidthF * 4 + 1];

	movzx	eax, BYTE PTR [rdx-1]
	mov	BYTE PTR g_new$[rsp+rcx-1], al

; 448  : 				b_new[i] = imgSrc[base + i * imgWidthF * 4 + 2];

	movzx	eax, BYTE PTR [rdx]
	add	rdx, rbx
	mov	BYTE PTR b_new$[rsp+rcx-1], al
	cmp	r8d, 5
	jl	SHORT $LL18@median_fil

; 9    : 	char pivot = nums[right], i, x;

	movzx	r11d, BYTE PTR r_new$[rsp+4]
	xor	ebx, ebx

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	xor	dl, dl
	xor	r8b, r8b
	npad	12
$LL584@median_fil:

; 14   : 		if (nums[x] <= pivot){

	lea	r9, QWORD PTR r_new$[rsp]
	movsx	rax, dl
	add	r9, rax
	movzx	r10d, BYTE PTR [r9]
	cmp	r10b, r11b
	jg	SHORT $LN583@median_fil

; 15   : 			SWAP(i, x);

	movsx	rax, r8b
	movzx	ecx, BYTE PTR r_new$[rsp+rax]
	mov	BYTE PTR r_new$[rsp+rax], r10b
	movzx	eax, r8b

; 16   : 			i++;

	lea	r8d, DWORD PTR [rdx+1]
	movzx	edx, al
	mov	BYTE PTR [r9], cl
$LN583@median_fil:

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	inc	dl
	cmp	dl, 4
	jl	SHORT $LL584@median_fil

; 17   : 		}
; 18   : 	}
; 19   : 	SWAP(i, right);

	movsx	rax, r8b
	lea	rcx, QWORD PTR r_new$[rsp]
	mov	r9d, 3
	add	rcx, rax
	movzx	eax, BYTE PTR r_new$[rsp+4]
	xor	r8d, r8d
	movzx	edx, BYTE PTR [rcx]
	mov	BYTE PTR [rcx], al
	lea	rcx, QWORD PTR r_new$[rsp]
	mov	BYTE PTR r_new$[rsp+4], dl
	lea	rdx, QWORD PTR r_new_p$[rsp]
	call	?quicksort@@YAXPEADPEACHH@Z		; quicksort

; 20   : 	return i;
; 21   : }
; 22   : 
; 23   : 
; 24   : void quicksort(char *nums, signed char* pos, int left, int right){
; 25   : 	//char new_p[5] = {21, 22, 23, 24, 25};
; 26   : 	signed char p;	//p is position of pivot in the partitioned array
; 27   : 	
; 28   : 	if (left < right){
; 29   : 		p = partition(nums, pos, left, right);
; 30   : 		quicksort(nums, pos, left, p - 1);
; 31   : 		quicksort(nums, pos, p + 1, right);
; 32   : 	}
; 33   : 	return;
; 34   : }
; 35   : /*
; 36   : int quickselect(char *nums, char* pos, int left, int right, int k){
; 37   : 	int p = partition(nums, new_p, left, right);	//p is position of pivot in the partitioned array
; 38   : 	int r;
; 39   : 	
; 40   : 	//k equals pivot got lucky
; 41   : 	if (p == k-1){
; 42   : 		r = nums[p];
; 43   : 	}
; 44   : 	//k less than pivot
; 45   : 	else if (k - 1 < p){
; 46   : 		r = quickselect(nums, new_p, left, p - 1, k);
; 47   : 	}
; 48   : 	//k greater than pivot
; 49   : 	else{
; 50   : 		r = quickselect(nums, new_p, p + 1, right, k);
; 51   : 	}
; 52   : 	pos = new_p;
; 53   : 	return r;
; 54   : }
; 55   : */
; 56   : 
; 57   : 
; 58   : void sort_and_merge(char* a, char* b, char* c, signed char* a_pos, signed char* b_pos, signed char* c_pos){
; 59   : 	int i, j, k;
; 60   : 	quicksort(c, c_pos, 0, FILTER_W-1);
; 61   : 	for(i = 0,j = 0, k = 0; i < FILTER_W * FILTER_H; i++){

	mov	rcx, rbx

; 68   : 			b[i] = c[j];

	mov	rdx, rbx
$LL575@median_fil:

; 62   : 		while(a_pos[i] < 1) k++;

	cmp	BYTE PTR r_b_p$[rbp+rcx-256], 1
	jl	$LL572@median_fil

; 63   : 		if(a[i+k] <= c[j]) {

	movzx	eax, BYTE PTR r_new$[rsp+rdx]
	lea	r8, QWORD PTR [rbx+rcx]
	movzx	r9d, BYTE PTR r_b$[rbp+r8-256]
	cmp	r9b, al
	jg	SHORT $LN570@median_fil

; 64   : 			b[i] = a[i+k];
; 65   : 			b_pos[i] = a_pos[i+k];

	movzx	eax, BYTE PTR r_b_p$[rbp+r8-256]
	mov	BYTE PTR r_a$[rbp+rcx-256], r9b

; 66   : 		}
; 67   : 		else {

	jmp	SHORT $LN1388@median_fil
$LN570@median_fil:

; 68   : 			b[i] = c[j];

	mov	BYTE PTR r_a$[rbp+rcx-256], al

; 69   : 			b_pos[i] = c_pos[j];

	movzx	eax, BYTE PTR r_new_p$[rsp+rdx]
	inc	rdx
$LN1388@median_fil:
	mov	BYTE PTR r_a_p$[rbp+rcx-256], al
	inc	rcx
	cmp	rcx, 25
	jl	SHORT $LL575@median_fil

; 9    : 	char pivot = nums[right], i, x;

	movzx	r11d, BYTE PTR g_new$[rsp+4]

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	xor	dl, dl
	xor	r8b, r8b
$LL612@median_fil:

; 14   : 		if (nums[x] <= pivot){

	lea	r9, QWORD PTR g_new$[rsp]
	movsx	rax, dl
	add	r9, rax
	movzx	r10d, BYTE PTR [r9]
	cmp	r10b, r11b
	jg	SHORT $LN611@median_fil

; 15   : 			SWAP(i, x);

	movsx	rax, r8b
	movzx	ecx, BYTE PTR g_new$[rsp+rax]
	mov	BYTE PTR g_new$[rsp+rax], r10b
	movzx	eax, r8b

; 16   : 			i++;

	lea	r8d, DWORD PTR [rdx+1]
	movzx	edx, al
	mov	BYTE PTR [r9], cl
$LN611@median_fil:

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	inc	dl
	cmp	dl, 4
	jl	SHORT $LL612@median_fil

; 17   : 		}
; 18   : 	}
; 19   : 	SWAP(i, right);

	movsx	rax, r8b
	lea	rcx, QWORD PTR g_new$[rsp]
	mov	r9d, 3
	add	rcx, rax
	movzx	eax, BYTE PTR g_new$[rsp+4]
	xor	r8d, r8d
	movzx	edx, BYTE PTR [rcx]
	mov	BYTE PTR [rcx], al
	lea	rcx, QWORD PTR g_new$[rsp]
	mov	BYTE PTR g_new$[rsp+4], dl
	lea	rdx, QWORD PTR g_new_p$[rsp]
	call	?quicksort@@YAXPEADPEACHH@Z		; quicksort

; 20   : 	return i;
; 21   : }
; 22   : 
; 23   : 
; 24   : void quicksort(char *nums, signed char* pos, int left, int right){
; 25   : 	//char new_p[5] = {21, 22, 23, 24, 25};
; 26   : 	signed char p;	//p is position of pivot in the partitioned array
; 27   : 	
; 28   : 	if (left < right){
; 29   : 		p = partition(nums, pos, left, right);
; 30   : 		quicksort(nums, pos, left, p - 1);
; 31   : 		quicksort(nums, pos, p + 1, right);
; 32   : 	}
; 33   : 	return;
; 34   : }
; 35   : /*
; 36   : int quickselect(char *nums, char* pos, int left, int right, int k){
; 37   : 	int p = partition(nums, new_p, left, right);	//p is position of pivot in the partitioned array
; 38   : 	int r;
; 39   : 	
; 40   : 	//k equals pivot got lucky
; 41   : 	if (p == k-1){
; 42   : 		r = nums[p];
; 43   : 	}
; 44   : 	//k less than pivot
; 45   : 	else if (k - 1 < p){
; 46   : 		r = quickselect(nums, new_p, left, p - 1, k);
; 47   : 	}
; 48   : 	//k greater than pivot
; 49   : 	else{
; 50   : 		r = quickselect(nums, new_p, p + 1, right, k);
; 51   : 	}
; 52   : 	pos = new_p;
; 53   : 	return r;
; 54   : }
; 55   : */
; 56   : 
; 57   : 
; 58   : void sort_and_merge(char* a, char* b, char* c, signed char* a_pos, signed char* b_pos, signed char* c_pos){
; 59   : 	int i, j, k;
; 60   : 	quicksort(c, c_pos, 0, FILTER_W-1);
; 61   : 	for(i = 0,j = 0, k = 0; i < FILTER_W * FILTER_H; i++){

	mov	rcx, rbx

; 68   : 			b[i] = c[j];

	mov	rdx, rbx
$LL603@median_fil:

; 62   : 		while(a_pos[i] < 1) k++;

	cmp	BYTE PTR g_b_p$[rbp+rcx-256], 1
	jl	$LL600@median_fil

; 63   : 		if(a[i+k] <= c[j]) {

	movzx	eax, BYTE PTR g_new$[rsp+rdx]
	lea	r8, QWORD PTR [rbx+rcx]
	movzx	r9d, BYTE PTR g_b$[rbp+r8-256]
	cmp	r9b, al
	jg	SHORT $LN598@median_fil

; 64   : 			b[i] = a[i+k];
; 65   : 			b_pos[i] = a_pos[i+k];

	movzx	eax, BYTE PTR g_b_p$[rbp+r8-256]
	mov	BYTE PTR g_a$[rbp+rcx-256], r9b

; 66   : 		}
; 67   : 		else {

	jmp	SHORT $LN1389@median_fil
$LN598@median_fil:

; 68   : 			b[i] = c[j];

	mov	BYTE PTR g_a$[rbp+rcx-256], al

; 69   : 			b_pos[i] = c_pos[j];

	movzx	eax, BYTE PTR g_new_p$[rsp+rdx]
	inc	rdx
$LN1389@median_fil:
	mov	BYTE PTR g_a_p$[rbp+rcx-256], al
	inc	rcx
	cmp	rcx, 25
	jl	SHORT $LL603@median_fil

; 9    : 	char pivot = nums[right], i, x;

	movzx	r11d, BYTE PTR b_new$[rsp+4]

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	xor	dl, dl
	xor	r8b, r8b
	npad	7
$LL640@median_fil:

; 14   : 		if (nums[x] <= pivot){

	lea	r9, QWORD PTR b_new$[rsp]
	movsx	rax, dl
	add	r9, rax
	movzx	r10d, BYTE PTR [r9]
	cmp	r10b, r11b
	jg	SHORT $LN639@median_fil

; 15   : 			SWAP(i, x);

	movsx	rax, r8b
	movzx	ecx, BYTE PTR b_new$[rsp+rax]
	mov	BYTE PTR b_new$[rsp+rax], r10b
	movzx	eax, r8b

; 16   : 			i++;

	lea	r8d, DWORD PTR [rdx+1]
	movzx	edx, al
	mov	BYTE PTR [r9], cl
$LN639@median_fil:

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	inc	dl
	cmp	dl, 4
	jl	SHORT $LL640@median_fil

; 17   : 		}
; 18   : 	}
; 19   : 	SWAP(i, right);

	movsx	rax, r8b
	lea	rcx, QWORD PTR b_new$[rsp]
	mov	r9d, 3
	add	rcx, rax
	movzx	eax, BYTE PTR b_new$[rsp+4]
	xor	r8d, r8d
	movzx	edx, BYTE PTR [rcx]
	mov	BYTE PTR [rcx], al
	lea	rcx, QWORD PTR b_new$[rsp]
	mov	BYTE PTR b_new$[rsp+4], dl
	lea	rdx, QWORD PTR b_new_p$[rsp]
	call	?quicksort@@YAXPEADPEACHH@Z		; quicksort

; 20   : 	return i;
; 21   : }
; 22   : 
; 23   : 
; 24   : void quicksort(char *nums, signed char* pos, int left, int right){
; 25   : 	//char new_p[5] = {21, 22, 23, 24, 25};
; 26   : 	signed char p;	//p is position of pivot in the partitioned array
; 27   : 	
; 28   : 	if (left < right){
; 29   : 		p = partition(nums, pos, left, right);
; 30   : 		quicksort(nums, pos, left, p - 1);
; 31   : 		quicksort(nums, pos, p + 1, right);
; 32   : 	}
; 33   : 	return;
; 34   : }
; 35   : /*
; 36   : int quickselect(char *nums, char* pos, int left, int right, int k){
; 37   : 	int p = partition(nums, new_p, left, right);	//p is position of pivot in the partitioned array
; 38   : 	int r;
; 39   : 	
; 40   : 	//k equals pivot got lucky
; 41   : 	if (p == k-1){
; 42   : 		r = nums[p];
; 43   : 	}
; 44   : 	//k less than pivot
; 45   : 	else if (k - 1 < p){
; 46   : 		r = quickselect(nums, new_p, left, p - 1, k);
; 47   : 	}
; 48   : 	//k greater than pivot
; 49   : 	else{
; 50   : 		r = quickselect(nums, new_p, p + 1, right, k);
; 51   : 	}
; 52   : 	pos = new_p;
; 53   : 	return r;
; 54   : }
; 55   : */
; 56   : 
; 57   : 
; 58   : void sort_and_merge(char* a, char* b, char* c, signed char* a_pos, signed char* b_pos, signed char* c_pos){
; 59   : 	int i, j, k;
; 60   : 	quicksort(c, c_pos, 0, FILTER_W-1);
; 61   : 	for(i = 0,j = 0, k = 0; i < FILTER_W * FILTER_H; i++){

	mov	rax, rbx

; 68   : 			b[i] = c[j];

	mov	rdx, rbx
$LL631@median_fil:

; 62   : 		while(a_pos[i] < 1) k++;

	cmp	BYTE PTR b_b_p$[rbp+rax-256], 1
	jl	$LL628@median_fil

; 63   : 		if(a[i+k] <= c[j]) {

	movzx	ecx, BYTE PTR b_new$[rsp+rdx]
	lea	r8, QWORD PTR [rbx+rax]
	movzx	r9d, BYTE PTR b_b$[rbp+r8-256]
	cmp	r9b, cl
	jg	SHORT $LN626@median_fil

; 64   : 			b[i] = a[i+k];
; 65   : 			b_pos[i] = a_pos[i+k];

	movzx	ecx, BYTE PTR b_b_p$[rbp+r8-256]
	mov	BYTE PTR b_a$[rbp+rax-256], r9b

; 66   : 		}
; 67   : 		else {

	jmp	SHORT $LN1390@median_fil
$LN626@median_fil:

; 68   : 			b[i] = c[j];

	mov	BYTE PTR b_a$[rbp+rax-256], cl

; 69   : 			b_pos[i] = c_pos[j];

	movzx	ecx, BYTE PTR b_new_p$[rsp+rdx]
	inc	rdx
$LN1390@median_fil:
	mov	BYTE PTR b_a_p$[rsp+rax], cl
	inc	rax
	cmp	rax, 25
	jl	SHORT $LL631@median_fil

; 449  : 			}
; 450  : 			
; 451  : 			//Sorting and merging the 2 tables
; 452  : 			sort_and_merge(r_b, r_a, r_new, r_b_p, r_a_p, r_new_p);
; 453  : 			sort_and_merge(g_b, g_a, g_new, g_b_p, g_a_p, g_new_p);
; 454  : 			sort_and_merge(b_b, b_a, b_new, b_b_p, b_a_p, b_new_p);
; 455  : 			
; 456  : 			//Writing out calculated pixel
; 457  : 			imgDst[base_out] 		= r_a[12];

	mov	rdx, QWORD PTR imgDst$GSCopy$1$[rsp]
	movzx	r15d, BYTE PTR r_a$[rbp-244]

; 458  : 			imgDst[base_out + 1]	= g_a[12];

	movzx	r12d, BYTE PTR g_a$[rbp-244]

; 459  : 			imgDst[base_out + 2]	= b_a[12];

	movzx	r13d, BYTE PTR b_a$[rbp-244]
	sub	r14d, 2
	mov	BYTE PTR [rdi+rdx-4], r15b
	mov	BYTE PTR [rdx+rdi-3], r12b
	mov	BYTE PTR [rdx+rdi-2], r13b

; 460  : 			
; 461  : 			base -= 4;
; 462  : 			base_out -= 4;

	sub	rdi, 8
	sub	rsi, 4
	test	r14d, r14d
	jg	$LL34@median_fil
$LN826@median_fil:

; 463  : 		}
; 464  : 		Y++;
; 465  : 		base = (Y * imgWidthF + imgFOffsetW) * 4; //base += (imgWidth + 1) * 4;

	mov	eax, DWORD PTR Y$1$[rsp]

; 466  : 		base_out = (Y * imgWidth) * 4;

	mov	edi, DWORD PTR imgWidth$GSCopy$1$[rsp]

; 467  : 		
; 468  : 		
; 469  : 		//Vertical movement, left side
; 470  : 
; 471  : 		for(i = 1; i < FILTER_H + 1; i++){

	mov	rcx, rbx
	imul	eax, DWORD PTR imgWidthF$1$[rsp]
	imul	edi, DWORD PTR Y$1$[rsp]
	shl	edi, 2
	lea	esi, DWORD PTR [rax*4+24]
	mov	eax, 1
	npad	3
$LL15@median_fil:

; 472  : 			r_new_p[i] = i;

	mov	BYTE PTR r_new_p$[rsp+rcx+1], al

; 473  : 			g_new_p[i] = i;

	mov	BYTE PTR g_new_p$[rsp+rcx+1], al

; 474  : 			b_new_p[i] = i;

	mov	BYTE PTR b_new_p$[rsp+rcx+1], al
	inc	eax
	lea	rcx, QWORD PTR [rcx+1]
	cmp	eax, 6
	jl	SHORT $LL15@median_fil

; 475  : 		}
; 476  : 		for(i = 0; i < FILTER_H * FILTER_W; i++){

	mov	r10d, ebx
	npad	6
$LL12@median_fil:

; 477  : 			if(r_a_p[i] % FILTER_H == 1 )

	movsxd	r8, r10d
	mov	eax, 1717986919				; 66666667H
	movsx	r9d, BYTE PTR r_a_p$[rbp+r8-256]
	mov	ecx, r9d
	imul	r9d
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	lea	eax, DWORD PTR [rdx+rdx*4]
	sub	ecx, eax
	cmp	ecx, 1
	jne	SHORT $LN9@median_fil

; 478  : 			r_a_p[i] = 0;

	cmp	r8, 25
	jae	$LN86@median_fil
	mov	BYTE PTR r_a_p$[rbp+r8-256], 0
	jmp	SHORT $LN8@median_fil
$LN9@median_fil:

; 479  : 			else r_a_p[i]--;

	dec	r9b
	mov	BYTE PTR r_a_p$[rbp+r8-256], r9b
$LN8@median_fil:

; 480  : 			if(g_a_p[i] % FILTER_H == 1 )

	movsx	r9d, BYTE PTR g_a_p$[rbp+r8-256]
	mov	eax, 1717986919				; 66666667H
	mov	ecx, r9d
	imul	r9d
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	lea	eax, DWORD PTR [rdx+rdx*4]
	sub	ecx, eax
	cmp	ecx, 1
	jne	SHORT $LN7@median_fil

; 481  : 			g_a_p[i] = 0;

	cmp	r8, 25
	jae	$LN88@median_fil
	mov	BYTE PTR g_a_p$[rbp+r8-256], 0
	jmp	SHORT $LN6@median_fil
$LN7@median_fil:

; 482  : 			else g_a_p[i]--;

	dec	r9b
	mov	BYTE PTR g_a_p$[rbp+r8-256], r9b
$LN6@median_fil:

; 483  : 			if(b_a_p[i] % FILTER_H == 1 )

	movsx	r9d, BYTE PTR b_a_p$[rsp+r8]
	mov	eax, 1717986919				; 66666667H
	mov	ecx, r9d
	imul	r9d
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	lea	eax, DWORD PTR [rdx+rdx*4]
	sub	ecx, eax
	cmp	ecx, 1
	jne	SHORT $LN5@median_fil

; 484  : 			b_a_p[i] = 0;

	cmp	r8, 25
	jae	$LN90@median_fil
	mov	BYTE PTR b_a_p$[rsp+r8], 0
	jmp	SHORT $LN11@median_fil
$LN5@median_fil:

; 485  : 			else b_a_p[i]--;

	dec	r9b
	mov	BYTE PTR b_a_p$[rsp+r8], r9b
$LN11@median_fil:

; 475  : 		}
; 476  : 		for(i = 0; i < FILTER_H * FILTER_W; i++){

	inc	r10d
	cmp	r10d, 25
	jl	$LL12@median_fil

; 486  : 		}
; 487  : 		
; 488  : 		for(i = 0; i < FILTER_W; i++){

	mov	rcx, QWORD PTR imgSrc$[rbp-256]
	movsxd	rax, esi

; 489  : 			r_new[i] = imgSrc[base + i * 4];

	mov	rdx, rbx
	add	rcx, 2
	mov	r8d, 5
	add	rcx, rax
	npad	12
$LL3@median_fil:
	movzx	eax, BYTE PTR [rcx-2]
	inc	rdx
	lea	rcx, QWORD PTR [rcx+4]
	mov	BYTE PTR r_new$[rsp+rdx-1], al

; 490  : 			g_new[i] = imgSrc[base + i * 4 + 1];

	movzx	eax, BYTE PTR [rcx-5]
	mov	BYTE PTR g_new$[rsp+rdx-1], al

; 491  : 			b_new[i] = imgSrc[base + i * 4 + 2];

	movzx	eax, BYTE PTR [rcx-4]
	mov	BYTE PTR b_new$[rsp+rdx-1], al
	dec	r8
	jne	SHORT $LL3@median_fil

; 9    : 	char pivot = nums[right], i, x;

	movzx	r11d, BYTE PTR r_new$[rsp+4]

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	xor	dl, dl
	npad	4
$LL668@median_fil:

; 14   : 		if (nums[x] <= pivot){

	lea	r9, QWORD PTR r_new$[rsp]
	movsx	rax, dl
	add	r9, rax
	movzx	r10d, BYTE PTR [r9]
	cmp	r10b, r11b
	jg	SHORT $LN667@median_fil

; 15   : 			SWAP(i, x);

	movsx	rax, r8b
	movzx	ecx, BYTE PTR r_new$[rsp+rax]
	mov	BYTE PTR r_new$[rsp+rax], r10b
	movzx	eax, r8b

; 16   : 			i++;

	lea	r8d, DWORD PTR [rdx+1]
	movzx	edx, al
	mov	BYTE PTR [r9], cl
$LN667@median_fil:

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	inc	dl
	cmp	dl, 4
	jl	SHORT $LL668@median_fil

; 17   : 		}
; 18   : 	}
; 19   : 	SWAP(i, right);

	movsx	rax, r8b
	lea	rcx, QWORD PTR r_new$[rsp]
	mov	r9d, 3
	add	rcx, rax
	movzx	eax, BYTE PTR r_new$[rsp+4]
	xor	r8d, r8d
	movzx	edx, BYTE PTR [rcx]
	mov	BYTE PTR [rcx], al
	lea	rcx, QWORD PTR r_new$[rsp]
	mov	BYTE PTR r_new$[rsp+4], dl
	lea	rdx, QWORD PTR r_new_p$[rsp]
	call	?quicksort@@YAXPEADPEACHH@Z		; quicksort

; 20   : 	return i;
; 21   : }
; 22   : 
; 23   : 
; 24   : void quicksort(char *nums, signed char* pos, int left, int right){
; 25   : 	//char new_p[5] = {21, 22, 23, 24, 25};
; 26   : 	signed char p;	//p is position of pivot in the partitioned array
; 27   : 	
; 28   : 	if (left < right){
; 29   : 		p = partition(nums, pos, left, right);
; 30   : 		quicksort(nums, pos, left, p - 1);
; 31   : 		quicksort(nums, pos, p + 1, right);
; 32   : 	}
; 33   : 	return;
; 34   : }
; 35   : /*
; 36   : int quickselect(char *nums, char* pos, int left, int right, int k){
; 37   : 	int p = partition(nums, new_p, left, right);	//p is position of pivot in the partitioned array
; 38   : 	int r;
; 39   : 	
; 40   : 	//k equals pivot got lucky
; 41   : 	if (p == k-1){
; 42   : 		r = nums[p];
; 43   : 	}
; 44   : 	//k less than pivot
; 45   : 	else if (k - 1 < p){
; 46   : 		r = quickselect(nums, new_p, left, p - 1, k);
; 47   : 	}
; 48   : 	//k greater than pivot
; 49   : 	else{
; 50   : 		r = quickselect(nums, new_p, p + 1, right, k);
; 51   : 	}
; 52   : 	pos = new_p;
; 53   : 	return r;
; 54   : }
; 55   : */
; 56   : 
; 57   : 
; 58   : void sort_and_merge(char* a, char* b, char* c, signed char* a_pos, signed char* b_pos, signed char* c_pos){
; 59   : 	int i, j, k;
; 60   : 	quicksort(c, c_pos, 0, FILTER_W-1);
; 61   : 	for(i = 0,j = 0, k = 0; i < FILTER_W * FILTER_H; i++){

	mov	rcx, rbx

; 68   : 			b[i] = c[j];

	mov	rdx, rbx
$LL659@median_fil:

; 62   : 		while(a_pos[i] < 1) k++;

	cmp	BYTE PTR r_a_p$[rbp+rcx-256], 1
	jl	$LL656@median_fil

; 63   : 		if(a[i+k] <= c[j]) {

	movzx	eax, BYTE PTR r_new$[rsp+rdx]
	lea	r8, QWORD PTR [rbx+rcx]
	movzx	r9d, BYTE PTR r_a$[rbp+r8-256]
	cmp	r9b, al
	jg	SHORT $LN654@median_fil

; 64   : 			b[i] = a[i+k];
; 65   : 			b_pos[i] = a_pos[i+k];

	movzx	eax, BYTE PTR r_a_p$[rbp+r8-256]
	mov	BYTE PTR r_b$[rbp+rcx-256], r9b

; 66   : 		}
; 67   : 		else {

	jmp	SHORT $LN1391@median_fil
$LN654@median_fil:

; 68   : 			b[i] = c[j];

	mov	BYTE PTR r_b$[rbp+rcx-256], al

; 69   : 			b_pos[i] = c_pos[j];

	movzx	eax, BYTE PTR r_new_p$[rsp+rdx]
	inc	rdx
$LN1391@median_fil:
	mov	BYTE PTR r_b_p$[rbp+rcx-256], al
	inc	rcx
	cmp	rcx, 25
	jl	SHORT $LL659@median_fil

; 9    : 	char pivot = nums[right], i, x;

	movzx	r11d, BYTE PTR g_new$[rsp+4]

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	xor	dl, dl
	xor	r8b, r8b
$LL696@median_fil:

; 14   : 		if (nums[x] <= pivot){

	lea	r9, QWORD PTR g_new$[rsp]
	movsx	rax, dl
	add	r9, rax
	movzx	r10d, BYTE PTR [r9]
	cmp	r10b, r11b
	jg	SHORT $LN695@median_fil

; 15   : 			SWAP(i, x);

	movsx	rax, r8b
	movzx	ecx, BYTE PTR g_new$[rsp+rax]
	mov	BYTE PTR g_new$[rsp+rax], r10b
	movzx	eax, r8b

; 16   : 			i++;

	lea	r8d, DWORD PTR [rdx+1]
	movzx	edx, al
	mov	BYTE PTR [r9], cl
$LN695@median_fil:

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	inc	dl
	cmp	dl, 4
	jl	SHORT $LL696@median_fil

; 17   : 		}
; 18   : 	}
; 19   : 	SWAP(i, right);

	movsx	rax, r8b
	lea	rcx, QWORD PTR g_new$[rsp]
	mov	r9d, 3
	add	rcx, rax
	movzx	eax, BYTE PTR g_new$[rsp+4]
	xor	r8d, r8d
	movzx	edx, BYTE PTR [rcx]
	mov	BYTE PTR [rcx], al
	lea	rcx, QWORD PTR g_new$[rsp]
	mov	BYTE PTR g_new$[rsp+4], dl
	lea	rdx, QWORD PTR g_new_p$[rsp]
	call	?quicksort@@YAXPEADPEACHH@Z		; quicksort

; 20   : 	return i;
; 21   : }
; 22   : 
; 23   : 
; 24   : void quicksort(char *nums, signed char* pos, int left, int right){
; 25   : 	//char new_p[5] = {21, 22, 23, 24, 25};
; 26   : 	signed char p;	//p is position of pivot in the partitioned array
; 27   : 	
; 28   : 	if (left < right){
; 29   : 		p = partition(nums, pos, left, right);
; 30   : 		quicksort(nums, pos, left, p - 1);
; 31   : 		quicksort(nums, pos, p + 1, right);
; 32   : 	}
; 33   : 	return;
; 34   : }
; 35   : /*
; 36   : int quickselect(char *nums, char* pos, int left, int right, int k){
; 37   : 	int p = partition(nums, new_p, left, right);	//p is position of pivot in the partitioned array
; 38   : 	int r;
; 39   : 	
; 40   : 	//k equals pivot got lucky
; 41   : 	if (p == k-1){
; 42   : 		r = nums[p];
; 43   : 	}
; 44   : 	//k less than pivot
; 45   : 	else if (k - 1 < p){
; 46   : 		r = quickselect(nums, new_p, left, p - 1, k);
; 47   : 	}
; 48   : 	//k greater than pivot
; 49   : 	else{
; 50   : 		r = quickselect(nums, new_p, p + 1, right, k);
; 51   : 	}
; 52   : 	pos = new_p;
; 53   : 	return r;
; 54   : }
; 55   : */
; 56   : 
; 57   : 
; 58   : void sort_and_merge(char* a, char* b, char* c, signed char* a_pos, signed char* b_pos, signed char* c_pos){
; 59   : 	int i, j, k;
; 60   : 	quicksort(c, c_pos, 0, FILTER_W-1);
; 61   : 	for(i = 0,j = 0, k = 0; i < FILTER_W * FILTER_H; i++){

	mov	rcx, rbx

; 68   : 			b[i] = c[j];

	mov	rdx, rbx
$LL687@median_fil:

; 62   : 		while(a_pos[i] < 1) k++;

	cmp	BYTE PTR g_a_p$[rbp+rcx-256], 1
	jl	$LL684@median_fil

; 63   : 		if(a[i+k] <= c[j]) {

	movzx	eax, BYTE PTR g_new$[rsp+rdx]
	lea	r8, QWORD PTR [rbx+rcx]
	movzx	r9d, BYTE PTR g_a$[rbp+r8-256]
	cmp	r9b, al
	jg	SHORT $LN682@median_fil

; 64   : 			b[i] = a[i+k];
; 65   : 			b_pos[i] = a_pos[i+k];

	movzx	eax, BYTE PTR g_a_p$[rbp+r8-256]
	mov	BYTE PTR g_b$[rbp+rcx-256], r9b

; 66   : 		}
; 67   : 		else {

	jmp	SHORT $LN1392@median_fil
$LN682@median_fil:

; 68   : 			b[i] = c[j];

	mov	BYTE PTR g_b$[rbp+rcx-256], al

; 69   : 			b_pos[i] = c_pos[j];

	movzx	eax, BYTE PTR g_new_p$[rsp+rdx]
	inc	rdx
$LN1392@median_fil:
	mov	BYTE PTR g_b_p$[rbp+rcx-256], al
	inc	rcx
	cmp	rcx, 25
	jl	SHORT $LL687@median_fil

; 9    : 	char pivot = nums[right], i, x;

	movzx	r11d, BYTE PTR b_new$[rsp+4]

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	xor	dl, dl
	xor	r8b, r8b
	npad	7
$LL724@median_fil:

; 14   : 		if (nums[x] <= pivot){

	lea	r9, QWORD PTR b_new$[rsp]
	movsx	rax, dl
	add	r9, rax
	movzx	r10d, BYTE PTR [r9]
	cmp	r10b, r11b
	jg	SHORT $LN723@median_fil

; 15   : 			SWAP(i, x);

	movsx	rax, r8b
	movzx	ecx, BYTE PTR b_new$[rsp+rax]
	mov	BYTE PTR b_new$[rsp+rax], r10b
	movzx	eax, r8b

; 16   : 			i++;

	lea	r8d, DWORD PTR [rdx+1]
	movzx	edx, al
	mov	BYTE PTR [r9], cl
$LN723@median_fil:

; 10   : 	
; 11   : 	#define SWAP(a, b) { tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; tmp_pos = a; a= b; b = tmp_pos; }
; 12   : 
; 13   : 	for (x = left, i = left; x < right; x++){

	inc	dl
	cmp	dl, 4
	jl	SHORT $LL724@median_fil

; 17   : 		}
; 18   : 	}
; 19   : 	SWAP(i, right);

	movsx	rax, r8b
	lea	rcx, QWORD PTR b_new$[rsp]
	mov	r9d, 3
	add	rcx, rax
	movzx	eax, BYTE PTR b_new$[rsp+4]
	xor	r8d, r8d
	movzx	edx, BYTE PTR [rcx]
	mov	BYTE PTR [rcx], al
	lea	rcx, QWORD PTR b_new$[rsp]
	mov	BYTE PTR b_new$[rsp+4], dl
	lea	rdx, QWORD PTR b_new_p$[rsp]
	call	?quicksort@@YAXPEADPEACHH@Z		; quicksort

; 20   : 	return i;
; 21   : }
; 22   : 
; 23   : 
; 24   : void quicksort(char *nums, signed char* pos, int left, int right){
; 25   : 	//char new_p[5] = {21, 22, 23, 24, 25};
; 26   : 	signed char p;	//p is position of pivot in the partitioned array
; 27   : 	
; 28   : 	if (left < right){
; 29   : 		p = partition(nums, pos, left, right);
; 30   : 		quicksort(nums, pos, left, p - 1);
; 31   : 		quicksort(nums, pos, p + 1, right);
; 32   : 	}
; 33   : 	return;
; 34   : }
; 35   : /*
; 36   : int quickselect(char *nums, char* pos, int left, int right, int k){
; 37   : 	int p = partition(nums, new_p, left, right);	//p is position of pivot in the partitioned array
; 38   : 	int r;
; 39   : 	
; 40   : 	//k equals pivot got lucky
; 41   : 	if (p == k-1){
; 42   : 		r = nums[p];
; 43   : 	}
; 44   : 	//k less than pivot
; 45   : 	else if (k - 1 < p){
; 46   : 		r = quickselect(nums, new_p, left, p - 1, k);
; 47   : 	}
; 48   : 	//k greater than pivot
; 49   : 	else{
; 50   : 		r = quickselect(nums, new_p, p + 1, right, k);
; 51   : 	}
; 52   : 	pos = new_p;
; 53   : 	return r;
; 54   : }
; 55   : */
; 56   : 
; 57   : 
; 58   : void sort_and_merge(char* a, char* b, char* c, signed char* a_pos, signed char* b_pos, signed char* c_pos){
; 59   : 	int i, j, k;
; 60   : 	quicksort(c, c_pos, 0, FILTER_W-1);
; 61   : 	for(i = 0,j = 0, k = 0; i < FILTER_W * FILTER_H; i++){

	mov	rcx, rbx

; 68   : 			b[i] = c[j];

	mov	rdx, rbx
$LL715@median_fil:

; 62   : 		while(a_pos[i] < 1) k++;

	cmp	BYTE PTR b_a_p$[rsp+rcx], 1
	jl	$LL712@median_fil

; 63   : 		if(a[i+k] <= c[j]) {

	movzx	eax, BYTE PTR b_new$[rsp+rdx]
	lea	r8, QWORD PTR [rbx+rcx]
	movzx	r9d, BYTE PTR b_a$[rbp+r8-256]
	cmp	r9b, al
	jg	SHORT $LN710@median_fil

; 64   : 			b[i] = a[i+k];
; 65   : 			b_pos[i] = a_pos[i+k];

	movzx	eax, BYTE PTR b_a_p$[rsp+r8]
	mov	BYTE PTR b_b$[rbp+rcx-256], r9b

; 66   : 		}
; 67   : 		else {

	jmp	SHORT $LN1393@median_fil
$LN710@median_fil:

; 68   : 			b[i] = c[j];

	mov	BYTE PTR b_b$[rbp+rcx-256], al

; 69   : 			b_pos[i] = c_pos[j];

	movzx	eax, BYTE PTR b_new_p$[rsp+rdx]
	inc	rdx
$LN1393@median_fil:
	mov	BYTE PTR b_b_p$[rbp+rcx-256], al
	inc	rcx
	cmp	rcx, 25
	jl	SHORT $LL715@median_fil

; 492  : 		}
; 493  : 		
; 494  : 		sort_and_merge(r_a, r_b, r_new, r_a_p, r_b_p, r_new_p);
; 495  : 		sort_and_merge(g_a, g_b, g_new, g_a_p, g_b_p, g_new_p);
; 496  : 		sort_and_merge(b_a, b_b, b_new, b_a_p, b_b_p, b_new_p);
; 497  : 		
; 498  : 		imgDst[base_out] 		= r_a[12];

	mov	rcx, QWORD PTR imgDst$GSCopy$1$[rsp]
	movsxd	rax, edi
	mov	BYTE PTR [rax+rcx], r15b

; 499  : 		imgDst[base_out + 1]	= g_a[12];

	mov	BYTE PTR [rax+rcx+1], r12b

; 500  : 		imgDst[base_out + 2]	= b_a[12];

	mov	BYTE PTR [rax+rcx+2], r13b
	mov	ecx, DWORD PTR Y$1$[rsp]
	cmp	ecx, DWORD PTR imgHeight$1$[rsp]
	jl	$LL65@median_fil
$LN1212@median_fil:
	mov	r15, QWORD PTR [rsp+584]
	mov	r13, QWORD PTR [rsp+576]
	mov	r12, QWORD PTR [rsp+560]

; 501  : 	}
; 502  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 512				; 00000200H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
$LL628@median_fil:

; 62   : 		while(a_pos[i] < 1) k++;

	lea	rbx, QWORD PTR [rbx+1]
	jmp	SHORT $LL628@median_fil
$LL600@median_fil:
	lea	rbx, QWORD PTR [rbx+1]
	jmp	SHORT $LL600@median_fil
	npad	3
$LL572@median_fil:
	lea	rbx, QWORD PTR [rbx+1]
	jmp	SHORT $LL572@median_fil
$LL544@median_fil:
	lea	rbx, QWORD PTR [rbx+1]
	jmp	SHORT $LL544@median_fil
	npad	4
$LL516@median_fil:
	lea	rbx, QWORD PTR [rbx+1]
	jmp	SHORT $LL516@median_fil
$LL488@median_fil:
	lea	rbx, QWORD PTR [rbx+1]
	jmp	SHORT $LL488@median_fil
	npad	4
$LL376@median_fil:
	lea	rbx, QWORD PTR [rbx+1]
	jmp	SHORT $LL376@median_fil
$LL348@median_fil:
	lea	rbx, QWORD PTR [rbx+1]
	jmp	SHORT $LL348@median_fil
	npad	4
$LL320@median_fil:
	lea	rbx, QWORD PTR [rbx+1]
	jmp	SHORT $LL320@median_fil
$LL292@median_fil:
	lea	rbx, QWORD PTR [rbx+1]
	jmp	SHORT $LL292@median_fil
	npad	4
$LL264@median_fil:
	lea	rbx, QWORD PTR [rbx+1]
	jmp	SHORT $LL264@median_fil
$LL236@median_fil:
	lea	rbx, QWORD PTR [rbx+1]
	jmp	SHORT $LL236@median_fil
	npad	4
$LL712@median_fil:
	lea	rbx, QWORD PTR [rbx+1]
	jmp	SHORT $LL712@median_fil
$LL684@median_fil:
	lea	rbx, QWORD PTR [rbx+1]
	jmp	SHORT $LL684@median_fil
	npad	4
$LL656@median_fil:
	lea	rbx, QWORD PTR [rbx+1]
	jmp	SHORT $LL656@median_fil
$LL460@median_fil:
	lea	rbx, QWORD PTR [rbx+1]
	jmp	SHORT $LL460@median_fil
	npad	4
$LL432@median_fil:
	lea	rbx, QWORD PTR [rbx+1]
	jmp	SHORT $LL432@median_fil
$LL404@median_fil:
	lea	rbx, QWORD PTR [rbx+1]
	jmp	SHORT $LL404@median_fil
	npad	4
$LL208@median_fil:
	lea	rbx, QWORD PTR [rbx+1]
	jmp	SHORT $LL208@median_fil
$LL180@median_fil:
	lea	rbx, QWORD PTR [rbx+1]
	jmp	SHORT $LL180@median_fil
	npad	4
$LL152@median_fil:
	lea	rbx, QWORD PTR [rbx+1]
	jmp	SHORT $LL152@median_fil
$LN1394@median_fil:

; 362  : 			if(r_a_p[i] % FILTER_H == 0) r_a_p[i] = 0;

	call	__report_rangecheckfailure
	int	3
$LN82@median_fil:

; 365  : 			if(g_a_p[i] % FILTER_H == 0) g_a_p[i] = 0;

	call	__report_rangecheckfailure
	int	3
$LN84@median_fil:

; 368  : 			if(b_a_p[i] % FILTER_H == 0) b_a_p[i] = 0;

	call	__report_rangecheckfailure
	int	3
$LN86@median_fil:

; 478  : 			r_a_p[i] = 0;

	call	__report_rangecheckfailure
	int	3
$LN88@median_fil:

; 481  : 			g_a_p[i] = 0;

	call	__report_rangecheckfailure
	int	3
$LN90@median_fil:

; 484  : 			b_a_p[i] = 0;

	call	__report_rangecheckfailure
	int	3
$LN1372@median_fil:
?median_filter_C@@YAXHHHHPEAD0@Z ENDP			; median_filter_C
_TEXT	ENDS
END
