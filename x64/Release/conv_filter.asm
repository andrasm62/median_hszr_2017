; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

include listing.inc

INCLUDELIB OLDNAMES

EXTRN	__security_check_cookie:PROC
PUBLIC	?conv_filter@@YAXHHHHHHPEAM00@Z			; conv_filter
PUBLIC	__real@40b3880000000000
PUBLIC	__real@412e848000000000
PUBLIC	__real@41c00000
PUBLIC	__real@437f0000
EXTRN	__GSHandlerCheck:PROC
EXTRN	_vcomp_for_static_end:PROC
EXTRN	_vcomp_for_static_simple_init:PROC
EXTRN	_vcomp_fork:PROC
EXTRN	_You_must_link_with_Microsoft_OpenMP_library:DWORD
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$?conv_filter@@YAXHHHHHHPEAM00@Z DD imagerel $LN2
	DD	imagerel $LN2+100
	DD	imagerel $unwind$?conv_filter@@YAXHHHHHHPEAM00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?conv_filter$omp$1@@YAXHHHHHHPEAM00@Z DD imagerel ?conv_filter$omp$1@@YAXHHHHHHPEAM00@Z
	DD	imagerel ?conv_filter$omp$1@@YAXHHHHHHPEAM00@Z+74
	DD	imagerel $unwind$?conv_filter$omp$1@@YAXHHHHHHPEAM00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?conv_filter$omp$1@@YAXHHHHHHPEAM00@Z DD imagerel ?conv_filter$omp$1@@YAXHHHHHHPEAM00@Z+74
	DD	imagerel ?conv_filter$omp$1@@YAXHHHHHHPEAM00@Z+130
	DD	imagerel $chain$1$?conv_filter$omp$1@@YAXHHHHHHPEAM00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?conv_filter$omp$1@@YAXHHHHHHPEAM00@Z DD imagerel ?conv_filter$omp$1@@YAXHHHHHHPEAM00@Z+130
	DD	imagerel ?conv_filter$omp$1@@YAXHHHHHHPEAM00@Z+563
	DD	imagerel $chain$6$?conv_filter$omp$1@@YAXHHHHHHPEAM00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?conv_filter$omp$1@@YAXHHHHHHPEAM00@Z DD imagerel ?conv_filter$omp$1@@YAXHHHHHHPEAM00@Z+563
	DD	imagerel ?conv_filter$omp$1@@YAXHHHHHHPEAM00@Z+584
	DD	imagerel $chain$7$?conv_filter$omp$1@@YAXHHHHHHPEAM00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?conv_filter$omp$1@@YAXHHHHHHPEAM00@Z DD imagerel ?conv_filter$omp$1@@YAXHHHHHHPEAM00@Z+584
	DD	imagerel ?conv_filter$omp$1@@YAXHHHHHHPEAM00@Z+611
	DD	imagerel $chain$8$?conv_filter$omp$1@@YAXHHHHHHPEAM00@Z
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@41c00000
CONST	SEGMENT
__real@41c00000 DD 041c00000r			; 24
CONST	ENDS
;	COMDAT __real@412e848000000000
CONST	SEGMENT
__real@412e848000000000 DQ 0412e848000000000r	; 1e+006
CONST	ENDS
;	COMDAT __real@40b3880000000000
CONST	SEGMENT
__real@40b3880000000000 DQ 040b3880000000000r	; 5000
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?conv_filter$omp$1@@YAXHHHHHHPEAM00@Z DD 021H
	DD	imagerel ?conv_filter$omp$1@@YAXHHHHHHPEAM00@Z
	DD	imagerel ?conv_filter$omp$1@@YAXHHHHHHPEAM00@Z+74
	DD	imagerel $unwind$?conv_filter$omp$1@@YAXHHHHHHPEAM00@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?conv_filter$omp$1@@YAXHHHHHHPEAM00@Z DD 021H
	DD	imagerel ?conv_filter$omp$1@@YAXHHHHHHPEAM00@Z+74
	DD	imagerel ?conv_filter$omp$1@@YAXHHHHHHPEAM00@Z+130
	DD	imagerel $chain$1$?conv_filter$omp$1@@YAXHHHHHHPEAM00@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?conv_filter$omp$1@@YAXHHHHHHPEAM00@Z DD 0a3921H
	DD	068839H
	DD	07782fH
	DD	086821H
	DD	0147418H
	DD	01c6408H
	DD	imagerel ?conv_filter$omp$1@@YAXHHHHHHPEAM00@Z+74
	DD	imagerel ?conv_filter$omp$1@@YAXHHHHHHPEAM00@Z+130
	DD	imagerel $chain$1$?conv_filter$omp$1@@YAXHHHHHHPEAM00@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?conv_filter$omp$1@@YAXHHHHHHPEAM00@Z DD 041921H
	DD	012e419H
	DD	013c404H
	DD	imagerel ?conv_filter$omp$1@@YAXHHHHHHPEAM00@Z
	DD	imagerel ?conv_filter$omp$1@@YAXHHHHHHPEAM00@Z+74
	DD	imagerel $unwind$?conv_filter$omp$1@@YAXHHHHHHPEAM00@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?conv_filter$omp$1@@YAXHHHHHHPEAM00@Z DD 061f19H
	DD	0150110H
	DD	0d007f009H
	DD	030045005H
	DD	imagerel __GSHandlerCheck
	DD	050H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?conv_filter@@YAXHHHHHHPEAM00@Z DD 011301H
	DD	0a213H
xdata	ENDS
; Function compile flags: /Ogtpy
; File c:\data\heterogen\gyakorlat\1_sse\masik_csoport\sse_lab\_src\conv_filter.cpp
;	COMDAT ?conv_filter$omp$1@@YAXHHHHHHPEAM00@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 52
imgFloatDst$GSCopy$1$ = 56
fval$3 = 64
__$ArrayPad$ = 80
imgHeight$ = 208
imgWidth$ = 216
imgWidthF$ = 224
filter$ = 232
imgFloatSrc$ = 240
imgFloatDst$ = 248
?conv_filter$omp$1@@YAXHHHHHHPEAM00@Z PROC		; conv_filter$omp$1, COMDAT
	mov	r11, rsp
	push	rbx
	push	rbp
	push	r13
	push	r15
	sub	rsp, 168				; 000000a8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbp, QWORD PTR imgFloatDst$[rsp]
	mov	rbx, rdx

; 19   : 	for (int row=0; row<imgHeight; row++)

	mov	edx, DWORD PTR [rcx]
	mov	r15, r9
	mov	r13, r8
	mov	QWORD PTR imgFloatDst$GSCopy$1$[rsp], rbp
	test	edx, edx
	jle	$LN1@conv_filte
	lea	rax, QWORD PTR $T1[rsp]
	mov	r9d, 1
	mov	QWORD PTR [r11-48], r12
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR $T2[rsp]
	dec	edx
	xor	ecx, ecx
	mov	r8d, r9d
	mov	QWORD PTR [r11-56], r14
	mov	QWORD PTR [rsp+32], rax
	call	_vcomp_for_static_simple_init
	mov	r14d, DWORD PTR $T2[rsp]
	mov	r12d, DWORD PTR $T1[rsp]
	cmp	r14d, r12d
	jg	$LN18@conv_filte

; 20   : 	{
; 21   : 		wr_base = (row * imgWidth) * 4;

	mov	ebx, DWORD PTR [rbx]
	mov	QWORD PTR [rsp+224], rsi
	mov	rsi, QWORD PTR imgFloatSrc$[rsp]
	mov	QWORD PTR [rsp+160], rdi
	vmovaps	XMMWORD PTR [rsp+128], xmm6
	vmovss	xmm6, DWORD PTR __real@437f0000
	vmovaps	XMMWORD PTR [rsp+112], xmm7
	vxorps	xmm7, xmm7, xmm7
	vmovaps	XMMWORD PTR [rsp+96], xmm8
	npad	5
$LL2@conv_filte:
	mov	eax, ebx
	imul	eax, r14d
	shl	eax, 2

; 22   : 		// A sorokon belül végiglépkedünk egy sor pixelein
; 23   : 		for (int col=0; col<imgWidth; col++)

	test	ebx, ebx
	jle	$LN17@conv_filte

; 24   : 		{
; 25   : 			rd_base = (row * imgWidthF + col) * 4;

	mov	edi, DWORD PTR [r13]
	lea	r11, QWORD PTR [rbp+8]
	cdqe
	lea	r11, QWORD PTR [r11+rax*4]
	mov	rbp, rbx
	imul	edi, r14d
	shl	edi, 2
	npad	7
$LL16@conv_filte:

; 26   : 			// RGBA komponensek akkumulátora
; 27   : 			float fval[4] = {0.0f, 0.0f, 0.0f, 0.0f};
; 28   : 			
; 29   : 			// konvolúció minden komponensre
; 30   : 
; 31   : 			for (int step_cntr = 0; step_cntr < FILTER_W * FILTER_H; step_cntr++){

	vxorps	xmm0, xmm0, xmm0
	xor	r8d, r8d
	mov	r9d, edi
	lea	r10d, QWORD PTR [r8+1]
	vmovups	XMMWORD PTR fval$3[rsp], xmm0
	vmovss	xmm8, DWORD PTR fval$3[rsp+12]
	vmovss	xmm5, DWORD PTR fval$3[rsp+8]
	vmovss	xmm4, DWORD PTR fval$3[rsp+4]
	vmovss	xmm3, DWORD PTR fval$3[rsp]
	npad	4
$LL13@conv_filte:

; 32   : 				for (int i = 0; i < 4; i++){
; 33   : 					fval[i] += imgFloatSrc[rd_base] * filter[step_cntr];

	vmovss	xmm2, DWORD PTR [r15+r8*4]
	movsxd	rax, r9d
	add	r9d, 4
	vmulss	xmm0, xmm2, DWORD PTR [rsi+rax*4]
	vmulss	xmm1, xmm2, DWORD PTR [rsi+rax*4+4]
	vaddss	xmm3, xmm3, xmm0
	vaddss	xmm4, xmm4, xmm1
	vmulss	xmm0, xmm2, DWORD PTR [rsi+rax*4+8]
	vmulss	xmm1, xmm2, DWORD PTR [rsi+rax*4+12]

; 34   : 					rd_base++;
; 35   : 				}
; 36   : 				if (((step_cntr+1) % FILTER_W) == 0){

	mov	eax, 1717986919				; 66666667H
	imul	r10d
	sar	edx, 1
	mov	eax, edx
	vaddss	xmm5, xmm5, xmm0
	vaddss	xmm8, xmm8, xmm1
	shr	eax, 31
	add	edx, eax
	lea	ecx, DWORD PTR [rdx+rdx*4]
	cmp	r10d, ecx
	jne	SHORT $LN12@conv_filte

; 37   : 					rd_base += 4 * imgWidth;

	lea	r9d, DWORD PTR [r9+rbx*4]
$LN12@conv_filte:

; 26   : 			// RGBA komponensek akkumulátora
; 27   : 			float fval[4] = {0.0f, 0.0f, 0.0f, 0.0f};
; 28   : 			
; 29   : 			// konvolúció minden komponensre
; 30   : 
; 31   : 			for (int step_cntr = 0; step_cntr < FILTER_W * FILTER_H; step_cntr++){

	inc	r8
	inc	r10d
	cmp	r8, 25
	jl	SHORT $LL13@conv_filte

; 38   : 				}
; 39   : 			}
; 40   : 			// kimeneti pixel írása, base címek módosítása
; 41   : 			for (int i = 0; i < 4; i++){
; 42   : 				if (fval[i] > 255){

	vcomiss	xmm3, xmm6
	jbe	SHORT $LN3@conv_filte

; 43   : 					fval[i] = 255;

	vmovups	xmm3, xmm6
	jmp	SHORT $LN1@conv_filte
$LN3@conv_filte:

; 44   : 				} else if (fval[i] < 0){

	vcomiss	xmm7, xmm3
	jbe	SHORT $LN1@conv_filte

; 45   : 					fval[i] = 0;

	vmovups	xmm3, xmm7
$LN1@conv_filte:

; 38   : 				}
; 39   : 			}
; 40   : 			// kimeneti pixel írása, base címek módosítása
; 41   : 			for (int i = 0; i < 4; i++){
; 42   : 				if (fval[i] > 255){

	vcomiss	xmm4, xmm6

; 46   : 				}
; 47   : 				imgFloatDst[wr_base] = fval[i];

	vmovss	DWORD PTR [r11-8], xmm3
	jbe	SHORT $LN42@conv_filte

; 43   : 					fval[i] = 255;

	vmovups	xmm4, xmm6
	jmp	SHORT $LN43@conv_filte
$LN42@conv_filte:

; 44   : 				} else if (fval[i] < 0){

	vcomiss	xmm7, xmm4
	jbe	SHORT $LN43@conv_filte

; 45   : 					fval[i] = 0;

	vmovups	xmm4, xmm7
$LN43@conv_filte:

; 38   : 				}
; 39   : 			}
; 40   : 			// kimeneti pixel írása, base címek módosítása
; 41   : 			for (int i = 0; i < 4; i++){
; 42   : 				if (fval[i] > 255){

	vcomiss	xmm5, xmm6

; 46   : 				}
; 47   : 				imgFloatDst[wr_base] = fval[i];

	vmovss	DWORD PTR [r11-4], xmm4
	jbe	SHORT $LN45@conv_filte

; 43   : 					fval[i] = 255;

	vmovups	xmm5, xmm6
	jmp	SHORT $LN46@conv_filte
$LN45@conv_filte:

; 44   : 				} else if (fval[i] < 0){

	vcomiss	xmm7, xmm5
	jbe	SHORT $LN46@conv_filte

; 45   : 					fval[i] = 0;

	vmovups	xmm5, xmm7
$LN46@conv_filte:

; 38   : 				}
; 39   : 			}
; 40   : 			// kimeneti pixel írása, base címek módosítása
; 41   : 			for (int i = 0; i < 4; i++){
; 42   : 				if (fval[i] > 255){

	vcomiss	xmm8, xmm6

; 46   : 				}
; 47   : 				imgFloatDst[wr_base] = fval[i];

	vmovss	DWORD PTR [r11], xmm5
	jbe	SHORT $LN48@conv_filte

; 43   : 					fval[i] = 255;

	vmovups	xmm8, xmm6
	jmp	SHORT $LN49@conv_filte
$LN48@conv_filte:

; 44   : 				} else if (fval[i] < 0){

	vcomiss	xmm7, xmm8
	jbe	SHORT $LN49@conv_filte

; 45   : 					fval[i] = 0;

	vmovups	xmm8, xmm7
$LN49@conv_filte:

; 46   : 				}
; 47   : 				imgFloatDst[wr_base] = fval[i];

	vmovss	DWORD PTR [r11+4], xmm8
	add	r11, 16
	add	edi, 4
	dec	rbp
	jne	$LL16@conv_filte
	mov	rbp, QWORD PTR imgFloatDst$GSCopy$1$[rsp]
$LN17@conv_filte:

; 19   : 	for (int row=0; row<imgHeight; row++)

	inc	r14d
	cmp	r14d, r12d
	jle	$LL2@conv_filte
	vmovaps	xmm8, XMMWORD PTR [rsp+96]
	vmovaps	xmm7, XMMWORD PTR [rsp+112]
	vmovaps	xmm6, XMMWORD PTR [rsp+128]
	mov	rdi, QWORD PTR [rsp+160]
	mov	rsi, QWORD PTR [rsp+224]
$LN18@conv_filte:
	call	_vcomp_for_static_end
	mov	r14, QWORD PTR [rsp+144]
	mov	r12, QWORD PTR [rsp+152]
$LN1@conv_filte:

; 48   : 				wr_base++;
; 49   : 			}
; 50   : 		}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 168				; 000000a8H
	pop	r15
	pop	r13
	pop	rbp
	pop	rbx
	ret	0
?conv_filter$omp$1@@YAXHHHHHHPEAM00@Z ENDP		; conv_filter$omp$1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\data\heterogen\gyakorlat\1_sse\masik_csoport\sse_lab\_src\conv_filter.cpp
;	COMDAT ?conv_filter@@YAXHHHHHHPEAM00@Z
_TEXT	SEGMENT
imgHeight$ = 96
imgWidth$ = 104
imgHeightF$dead$ = 112
imgWidthF$ = 120
imgFOffsetH$dead$ = 128
imgFOffsetW$dead$ = 136
filter$ = 144
imgFloatSrc$ = 152
imgFloatDst$ = 160
?conv_filter@@YAXHHHHHHPEAM00@Z PROC			; conv_filter, COMDAT

; 11   : {

$LN2:
	mov	r11, rsp
	mov	DWORD PTR [r11+32], r9d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 88					; 00000058H

; 12   : 	// írási bázis: 0. sor, 0. oszlop (a kimenet NEM kiterjesztett)
; 13   : 	int wr_base = 0;
; 14   : 	// olvasási bázis: a kiterjesztett kép bal felsõ pixele (ez az elsõ konvolúció elsõ bemeneti adata)
; 15   : 	int rd_base = 0;
; 16   : 	
; 17   : 	// Végiglépkedünk a kép sorain
; 18   : 	#pragma omp parallel for private(rd_base, wr_base)

	mov	rax, QWORD PTR imgFloatDst$[rsp]
	mov	edx, 6
	lea	r9, QWORD PTR [r11+8]
	mov	QWORD PTR [r11-24], rax
	mov	rax, QWORD PTR imgFloatSrc$[rsp]
	lea	r8, OFFSET FLAT:?conv_filter$omp$1@@YAXHHHHHHPEAM00@Z ; conv_filter$omp$1
	mov	QWORD PTR [r11-32], rax
	mov	rax, QWORD PTR filter$[rsp]
	lea	ecx, QWORD PTR [rdx-5]
	mov	QWORD PTR [r11-40], rax
	lea	rax, QWORD PTR [r11+32]
	mov	QWORD PTR [r11-48], rax
	lea	rax, QWORD PTR [r11+16]
	mov	QWORD PTR [r11-56], rax
	call	_vcomp_fork

; 19   : 	for (int row=0; row<imgHeight; row++)
; 20   : 	{
; 21   : 		wr_base = (row * imgWidth) * 4;
; 22   : 		// A sorokon belül végiglépkedünk egy sor pixelein
; 23   : 		for (int col=0; col<imgWidth; col++)
; 24   : 		{
; 25   : 			rd_base = (row * imgWidthF + col) * 4;
; 26   : 			// RGBA komponensek akkumulátora
; 27   : 			float fval[4] = {0.0f, 0.0f, 0.0f, 0.0f};
; 28   : 			
; 29   : 			// konvolúció minden komponensre
; 30   : 
; 31   : 			for (int step_cntr = 0; step_cntr < FILTER_W * FILTER_H; step_cntr++){
; 32   : 				for (int i = 0; i < 4; i++){
; 33   : 					fval[i] += imgFloatSrc[rd_base] * filter[step_cntr];
; 34   : 					rd_base++;
; 35   : 				}
; 36   : 				if (((step_cntr+1) % FILTER_W) == 0){
; 37   : 					rd_base += 4 * imgWidth;
; 38   : 				}
; 39   : 			}
; 40   : 			// kimeneti pixel írása, base címek módosítása
; 41   : 			for (int i = 0; i < 4; i++){
; 42   : 				if (fval[i] > 255){
; 43   : 					fval[i] = 255;
; 44   : 				} else if (fval[i] < 0){
; 45   : 					fval[i] = 0;
; 46   : 				}
; 47   : 				imgFloatDst[wr_base] = fval[i];
; 48   : 				wr_base++;
; 49   : 			}
; 50   : 		}
; 51   : 	}
; 52   : }

	add	rsp, 88					; 00000058H
	ret	0
?conv_filter@@YAXHHHHHHPEAM00@Z ENDP			; conv_filter
_TEXT	ENDS
END
