; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_09HDLCNAPM@input?4jpg?$AA@		; `string'
PUBLIC	??_C@_0BL@EIJCCJGD@Input?5resolution?3?5?$CF4dx?$CF4d?6?$AA@ ; `string'
PUBLIC	??_C@_04HGIPLDBL@?$CFd?$AN?6?$AA@		; `string'
PUBLIC	??_C@_0BD@NGKMKCMP@C?5CPU?5TIME?3?5?$CF4?44f?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@CKJPLJHO@C?5Mpixel?1s?3?5?$CF4?44f?6?$AA@ ; `string'
PUBLIC	??_C@_0L@DMOPMCBB@output?4jpg?$AA@		; `string'
EXTRN	getchar:PROC
EXTRN	__imp_ilGetInteger:PROC
EXTRN	_aligned_malloc:PROC
EXTRN	_aligned_free:PROC
EXTRN	__imp_iluInit:PROC
EXTRN	clock:PROC
EXTRN	__imp_ilInit:PROC
EXTRN	printf:PROC
EXTRN	__imp_ilDeleteImages:PROC
EXTRN	__imp_ilEnable:PROC
EXTRN	__imp_ilLoadImage:PROC
EXTRN	__imp_ilSetData:PROC
EXTRN	__imp_ilGetData:PROC
EXTRN	__imp_ilBindImage:PROC
EXTRN	__imp_ilGenImages:PROC
EXTRN	__imp_ilSaveImage:PROC
;	COMDAT ??_C@_0L@DMOPMCBB@output?4jpg?$AA@
CONST	SEGMENT
??_C@_0L@DMOPMCBB@output?4jpg?$AA@ DB 'output.jpg', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CKJPLJHO@C?5Mpixel?1s?3?5?$CF4?44f?6?$AA@
CONST	SEGMENT
??_C@_0BD@CKJPLJHO@C?5Mpixel?1s?3?5?$CF4?44f?6?$AA@ DB 'C Mpixel/s: %4.4f'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NGKMKCMP@C?5CPU?5TIME?3?5?$CF4?44f?6?$AA@
CONST	SEGMENT
??_C@_0BD@NGKMKCMP@C?5CPU?5TIME?3?5?$CF4?44f?6?$AA@ DB 'C CPU TIME: %4.4f'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_04HGIPLDBL@?$CFd?$AN?6?$AA@
CONST	SEGMENT
??_C@_04HGIPLDBL@?$CFd?$AN?6?$AA@ DB '%d', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@EIJCCJGD@Input?5resolution?3?5?$CF4dx?$CF4d?6?$AA@
CONST	SEGMENT
??_C@_0BL@EIJCCJGD@Input?5resolution?3?5?$CF4dx?$CF4d?6?$AA@ DB 'Input re'
	DB	'solution: %4dx%4d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09HDLCNAPM@input?4jpg?$AA@
CONST	SEGMENT
??_C@_09HDLCNAPM@input?4jpg?$AA@ DB 'input.jpg', 00H	; `string'
CONST	ENDS
PUBLIC	main
;	COMDAT pdata
pdata	SEGMENT
$pdata$main DD	imagerel $LN53
	DD	imagerel $LN53+753
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main DD	0c1a01H
	DD	03681aH
	DD	0133414H
	DD	0f0107214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
; Function compile flags: /Ogtpy
; File c:\data\heterogen\c_optimalizalatlan\_src\main.cpp
;	COMDAT main
_TEXT	SEGMENT
ilImg$ = 128
imgData$1$ = 136
tv2093 = 144
main	PROC						; COMDAT

; 19   : {

$LN53:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H
	vmovaps	XMMWORD PTR [rsp+48], xmm6

; 20   : 	ilInit();

	call	QWORD PTR __imp_ilInit

; 21   : 	iluInit();

	call	QWORD PTR __imp_iluInit

; 22   : 	ILboolean ret;
; 23   : 	ILuint ilImg = 0;

	xor	esi, esi

; 24   : 	ilGenImages(1, &ilImg);

	lea	rdx, QWORD PTR ilImg$[rsp]
	lea	ecx, QWORD PTR [rsi+1]
	mov	DWORD PTR ilImg$[rsp], esi
	call	QWORD PTR __imp_ilGenImages

; 25   : 	ilBindImage(ilImg);

	mov	ecx, DWORD PTR ilImg$[rsp]
	call	QWORD PTR __imp_ilBindImage

; 26   : 	ret = ilLoadImage((const char*)("input.jpg"));

	lea	rcx, OFFSET FLAT:??_C@_09HDLCNAPM@input?4jpg?$AA@
	call	QWORD PTR __imp_ilLoadImage

; 27   : 	ILubyte* imgData = ilGetData(); 

	call	QWORD PTR __imp_ilGetData

; 28   : 
; 29   : 	int imgWidth	= ilGetInteger(IL_IMAGE_WIDTH);

	mov	ecx, 3556				; 00000de4H
	mov	r15, rax
	mov	QWORD PTR imgData$1$[rsp], rax
	call	QWORD PTR __imp_ilGetInteger

; 30   : 	int imgHeight	= ilGetInteger(IL_IMAGE_HEIGHT);

	mov	ecx, 3557				; 00000de5H
	mov	ebx, eax
	call	QWORD PTR __imp_ilGetInteger

; 31   : 	ILint imgOrigin	= ilGetInteger(IL_ORIGIN_MODE);

	mov	ecx, 1539				; 00000603H
	mov	r13d, eax
	call	QWORD PTR __imp_ilGetInteger

; 32   : 
; 33   : 	printf("Input resolution: %4dx%4d\n", imgWidth, imgHeight);

	lea	rcx, OFFSET FLAT:??_C@_0BL@EIJCCJGD@Input?5resolution?3?5?$CF4dx?$CF4d?6?$AA@
	mov	r8d, r13d
	mov	edx, ebx
	call	printf

; 34   : 
; 35   : 	char *img;
; 36   : 	int imgWidthF = imgWidth + FILTER_W - 1 + 2;
; 37   : 	int imgHeightF = imgHeight + FILTER_H - 1;

	lea	ebp, DWORD PTR [r13+4]
	lea	edi, DWORD PTR [rbx+6]

; 38   : 	int imgFOffsetW = (FILTER_W-1) + 2;
; 39   : 	int imgFOffsetH = (FILTER_H-1)/2;
; 40   : 	img = (char *)(_aligned_malloc(4*imgWidthF*imgHeightF*sizeof(char), 32));

	mov	eax, ebp
	lea	edx, QWORD PTR [rsi+32]
	imul	eax, edi
	shl	eax, 2
	cdqe
	mov	rcx, rax
	mov	QWORD PTR tv2093[rsp], rax
	call	_aligned_malloc
	mov	r12, rax

; 41   : 	int row, col;
; 42   : 
; 43   : 	for (row=0; row<imgHeightF; row++)

	test	ebp, ebp
	jle	SHORT $LN19@main

; 20   : 	ilInit();

	lea	ecx, DWORD PTR [rdi*4]
	lea	rdx, QWORD PTR [rax+2]
	mov	r8d, ebp
	movsxd	r9, ecx
	npad	2
$LL21@main:

; 44   : 	{
; 45   : 		for (col=0; col<imgWidthF;col++)

	test	edi, edi
	jle	SHORT $LN20@main
	mov	rcx, rdx
	mov	eax, edi
	npad	7
$LL18@main:

; 46   : 		{
; 47   : 			int pixel = (row*imgWidthF + col)*4;
; 48   : 			*(img+pixel+0) = 0;

	mov	DWORD PTR [rcx-2], esi
	lea	rcx, QWORD PTR [rcx+4]
	dec	rax
	jne	SHORT $LL18@main
$LN20@main:

; 41   : 	int row, col;
; 42   : 
; 43   : 	for (row=0; row<imgHeightF; row++)

	add	rdx, r9
	dec	r8
	jne	SHORT $LL21@main
$LN19@main:

; 49   : 			*(img + pixel + 1) = 0;
; 50   : 			*(img + pixel + 2) = 0;
; 51   : 			*(img + pixel + 3) = 0;
; 52   : 		}
; 53   : 	}
; 54   : 
; 55   : 	for (row=0; row<imgHeight; row++)

	test	r13d, r13d
	jle	SHORT $LN13@main
	lea	eax, DWORD PTR [rbx+rbx*2]
	lea	r10, QWORD PTR [r15+2]
	lea	r11, QWORD PTR [r12+2]
	movsxd	r14, eax
	lea	eax, DWORD PTR [rdi*4]
	mov	rbp, r13
	movsxd	r15, eax
	lea	eax, DWORD PTR [rdi*8+24]
	movsxd	rcx, eax
	add	r11, rcx
$LL15@main:

; 56   : 	{
; 57   : 		for (col=0; col<imgWidth;col++)

	test	ebx, ebx
	jle	SHORT $LN14@main
	mov	rcx, r11
	mov	r8, r10
	mov	r9, rbx
	npad	1
$LL12@main:

; 58   : 		{
; 59   : 			int pixel_dst = ((row+imgFOffsetH)*imgWidthF + (col+imgFOffsetW))*4;
; 60   : 			int pixel_src = (row*imgWidth + col)*3;
; 61   : 			*(img+pixel_dst+0) = (char)(*(imgData+pixel_src+0));

	movzx	eax, BYTE PTR [r8-2]

; 62   : 			*(img+pixel_dst+1) = (char)(*(imgData+pixel_src+1));
; 63   : 			*(img+pixel_dst+2) = (char)(*(imgData+pixel_src+2));
; 64   : 			*(img+pixel_dst+3) = 0;

	mov	BYTE PTR [rcx+1], sil
	lea	rcx, QWORD PTR [rcx+4]
	mov	BYTE PTR [rcx-6], al
	movzx	eax, BYTE PTR [r8-1]
	lea	r8, QWORD PTR [r8+3]
	mov	BYTE PTR [rcx-5], al
	movzx	eax, BYTE PTR [r8-3]
	mov	BYTE PTR [rcx-4], al
	dec	r9
	jne	SHORT $LL12@main
$LN14@main:

; 49   : 			*(img + pixel + 1) = 0;
; 50   : 			*(img + pixel + 2) = 0;
; 51   : 			*(img + pixel + 3) = 0;
; 52   : 		}
; 53   : 	}
; 54   : 
; 55   : 	for (row=0; row<imgHeight; row++)

	add	r11, r15
	add	r10, r14
	dec	rbp
	jne	SHORT $LL15@main
	mov	r15, QWORD PTR imgData$1$[rsp]
$LN13@main:

; 65   : 		}
; 66   : 	}
; 67   : 
; 68   : 
; 69   : // IMAGE PROCESSING
; 70   : //---------------------------------------------------------------------------------------
; 71   : 	clock_t s0, e0;
; 72   : 	double d0;
; 73   : 
; 74   : 	char *imgRes;
; 75   : 	imgRes = (char *)(_aligned_malloc(4 * imgWidthF * imgHeightF * sizeof(char), 32));

	mov	rcx, QWORD PTR tv2093[rsp]
	mov	edx, 32					; 00000020H
	call	_aligned_malloc
	mov	rbp, rax

; 76   : 
; 77   : 	double mpixel;
; 78   : 
; 79   : 	s0 = clock();

	call	clock
	mov	r14d, eax
	npad	7
$LL9@main:

; 80   : 	for (int r = 0; r < RUNS; r++)
; 81   : 	{
; 82   : 		median_filter_C(imgHeight, imgWidth, imgWidthF, imgFOffsetW, img, imgRes);

	mov	r8d, edi
	mov	edx, ebx
	mov	ecx, r13d
	mov	QWORD PTR [rsp+40], rbp
	mov	QWORD PTR [rsp+32], r12
	call	?median_filter_C@@YAXHHHHPEAD0@Z	; median_filter_C

; 83   : 
; 84   : 
; 85   : 		printf("%d\r\n", r);

	lea	rcx, OFFSET FLAT:??_C@_04HGIPLDBL@?$CFd?$AN?6?$AA@
	mov	edx, esi
	call	printf
	inc	esi
	cmp	esi, 10
	jl	SHORT $LL9@main

; 86   : 
; 87   : 	}
; 88   : 
; 89   : 	e0 = clock();

	call	clock

; 90   : 	d0 = (double)(e0-s0)/(RUNS*CLOCKS_PER_SEC);
; 91   : 	mpixel = (imgWidth*imgHeight/d0)/1000000;
; 92   : 	printf("C CPU TIME: %4.4f\n", d0);

	lea	rcx, OFFSET FLAT:??_C@_0BD@NGKMKCMP@C?5CPU?5TIME?3?5?$CF4?44f?6?$AA@
	sub	eax, r14d
	vmovd	xmm0, eax
	vcvtdq2pd xmm0, xmm0
	vdivsd	xmm6, xmm0, QWORD PTR __real@40c3880000000000
	vmovd	rdx, xmm6
	vmovups	xmm1, xmm6
	call	printf
	mov	eax, r13d

; 93   : 	printf("C Mpixel/s: %4.4f\n", mpixel);

	lea	rcx, OFFSET FLAT:??_C@_0BD@CKJPLJHO@C?5Mpixel?1s?3?5?$CF4?44f?6?$AA@
	imul	eax, ebx
	vmovd	xmm0, eax
	vcvtdq2pd xmm0, xmm0
	vdivsd	xmm1, xmm0, xmm6
	vdivsd	xmm1, xmm1, QWORD PTR __real@412e848000000000
	vmovd	rdx, xmm1
	call	printf

; 94   : 	getchar();

	call	getchar

; 95   : 
; 96   : 
; 97   : 	char *imgWrite;
; 98   : 	imgWrite = imgRes;
; 99   : 
; 100  : //---------------------------------------------------------------------------------------
; 101  : // IMAGE PROCESSING END
; 102  : 
; 103  : 
; 104  : 	for (row=0; row<imgHeight; row++)

	test	r13d, r13d
	jle	SHORT $LN4@main

; 86   : 
; 87   : 	}
; 88   : 
; 89   : 	e0 = clock();

	lea	eax, DWORD PTR [rbx*4]
	lea	r9, QWORD PTR [rbp+2]
	lea	r10, QWORD PTR [r15+2]
	movsxd	rdi, eax
	lea	eax, DWORD PTR [rbx+rbx*2]
	mov	r11, r13
	movsxd	rsi, eax
	npad	7
$LL6@main:

; 105  : 	{
; 106  : 		for (col=0; col<imgWidth;col++)

	test	ebx, ebx
	jle	SHORT $LN5@main
	mov	rcx, r10
	mov	rdx, r9
	mov	r8, rbx
	npad	3
$LL3@main:

; 107  : 		{
; 108  : 			int pixel_src = (row*imgWidth + col)*4;
; 109  : 			int pixel_dst = (row*imgWidth + col)*3;
; 110  : 			*(imgData+pixel_dst+0) = (ILubyte)(*(imgWrite+pixel_src+0));

	movzx	eax, BYTE PTR [rdx-2]
	lea	rcx, QWORD PTR [rcx+3]
	lea	rdx, QWORD PTR [rdx+4]
	mov	BYTE PTR [rcx-5], al

; 111  : 			*(imgData+pixel_dst+1) = (ILubyte)(*(imgWrite+pixel_src+1));

	movzx	eax, BYTE PTR [rdx-5]
	mov	BYTE PTR [rcx-4], al

; 112  : 			*(imgData+pixel_dst+2) = (ILubyte)(*(imgWrite+pixel_src+2));

	movzx	eax, BYTE PTR [rdx-4]
	mov	BYTE PTR [rcx-3], al
	dec	r8
	jne	SHORT $LL3@main
$LN5@main:

; 95   : 
; 96   : 
; 97   : 	char *imgWrite;
; 98   : 	imgWrite = imgRes;
; 99   : 
; 100  : //---------------------------------------------------------------------------------------
; 101  : // IMAGE PROCESSING END
; 102  : 
; 103  : 
; 104  : 	for (row=0; row<imgHeight; row++)

	add	r10, rsi
	add	r9, rdi
	dec	r11
	jne	SHORT $LL6@main
$LN4@main:

; 113  : 		}
; 114  : 	}
; 115  : 
; 116  : 
; 117  : 	_aligned_free(img);

	mov	rcx, r12
	call	_aligned_free

; 118  : 	_aligned_free(imgRes);

	mov	rcx, rbp
	call	_aligned_free

; 119  : 
; 120  : 	ret = ilSetData(imgData);

	mov	rcx, r15
	call	QWORD PTR __imp_ilSetData

; 121  : 	ilEnable(IL_FILE_OVERWRITE);

	mov	ecx, 1568				; 00000620H
	call	QWORD PTR __imp_ilEnable

; 122  : 	ilSaveImage((const char*)("output.jpg"));

	lea	rcx, OFFSET FLAT:??_C@_0L@DMOPMCBB@output?4jpg?$AA@
	call	QWORD PTR __imp_ilSaveImage

; 123  : 	ilDeleteImages(1, &ilImg);

	lea	rdx, QWORD PTR ilImg$[rsp]
	mov	ecx, 1
	call	QWORD PTR __imp_ilDeleteImages

; 124  : }

	mov	rbx, QWORD PTR [rsp+152]
	xor	eax, eax
	vmovaps	xmm6, XMMWORD PTR [rsp+48]
	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
main	ENDP
_TEXT	ENDS
END
